<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Ncqrs</name>
  </assembly>
  <members>
    <member name="T:Ncqrs.Domain.Storage.IDomainRepository">
      <summary>
            A repository that can be used to get and save aggregate roots.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.Storage.IDomainRepository.GetById(System.Type,System.Guid)">
      <summary>
            Gets aggregate root by eventSourceId.
            </summary>
      <param name="aggregateRootType">Type of the aggregate root.</param>
      <param name="eventSourceId">The eventSourceId of the aggregate root.</param>
      <returns>A new instance of the aggregate root that contains the latest known state.</returns>
      <requires exception="T:System.ArgumentNullException">aggregateRootType != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRootType == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Storage.IDomainRepository.GetById``1(System.Guid)">
      <summary>
            Gets aggregate root by eventSourceId.
            </summary>
      <typeparam name="T">The type of the aggregate root.</typeparam>
      <param name="eventSourceId">The eventSourceId of the aggregate root.</param>
      <returns>A new instance of the aggregate root that contains the latest known state.</returns>
    </member>
    <member name="M:Ncqrs.Domain.Storage.IDomainRepository.Save(Ncqrs.Domain.AggregateRoot)">
      <summary>
            Saves the specified aggregate root.
            </summary>
      <param name="aggregateRootToSave">The aggregate root to save.</param>
      <requires exception="T:System.ArgumentNullException">aggregateRootToSave != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRootToSave == null</exception>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.Snapshotting.Snapshot">
      <summary>
            Holds the full state of an <see cref="T:Ncqrs.Eventing.Sourcing.IEventSource" /> at a certain version.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.Snapshotting.ISnapshot">
      <summary>
            Holds the full state of an <see cref="T:Ncqrs.Eventing.Sourcing.IEventSource" /> at a certain version.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.Snapshotting.ISnapshot.EventSourceId">
      <summary>
            Gets the event source id.
            </summary>
      <value>The event source id.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.Snapshotting.ISnapshot.EventSourceVersion">
      <summary>
            Gets the version of the event source from when this snapshot was created.
            </summary>
      <value>The event source version.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.Snapshotting.Snapshot.EventSourceId">
      <summary>
            Gets the id of the event source from which this snapshot was created.
            </summary>
      <remarks>
            The id of the event source from which this snapshot was created.
            </remarks>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.Snapshotting.Snapshot.EventSourceVersion">
      <summary>
            Gets the version of the event source when this snapshot was created.
            </summary>
      <value>The version of the event source when this snapshot was created.</value>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.Mapping.ExpressionHandler">
      <summary>
            The base implementation for the handling of expression based mapping.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.Mapping.ExpressionHandler.ActionMethodInfo">
      <summary>
            Gets the action that is to be invoked.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.Mapping.ExpressionHandler.Exact">
      <summary>
            Gets the value that determines if the given mapping should match exactly.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.Mapping.ExpressionHandler`1">
      <summary>
            The generic base implementation for the handling of expression based mapping.
            </summary>
      <typeparam name="T">This should always be a <see cref="T:Ncqrs.Eventing.Sourcing.SourcedEvent" />.</typeparam>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.Mapping.ExpressionHandler`1.ToHandler(System.Action{`0})">
      <summary>
            Stores the given <see cref="T:System.Action`1" /> action.
            </summary>
      <param name="mappingaction">The <see cref="T:System.Action`1" /> to map.</param>
      <returns>Itself <see cref="T:Ncqrs.Eventing.Sourcing.Mapping.ExpressionHandler`1" />.</returns>
      <requires description="The mappingaction can not be null." exception="T:System.ArgumentNullException">mappingaction != null</requires>
      <exception cref="T:System.ArgumentNullException">mappingaction == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.Mapping.ExpressionHandler`1.MatchExact">
      <summary>
            Determines that the action should map <b>exactly</b> on the given method in the given type.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.ExcludeInMappingAttribute">
      <summary>
            Defines that a property should be excluded in the auto mapping process.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.AggregateRootIdAttribute">
      <summary>
            Marks a property as the property that contains the aggregate root id.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.CommandMappingAttribute">
      <summary>
            Base class for attribute based command mapping. It defines
            a method that enables the creation of a <see cref="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1" /> 
            by the attribute.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.CommandMappingAttribute.CreateExecutor``1">
      <summary>
            Creates the executor based on the mapping defined by the attribute.
            </summary>
      <typeparam name="TCommand">The type of the command. This should be the type
            of where the attribute was defined on.</typeparam>
      <returns>A new <see cref="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1" /> created based on the mapping.</returns>
    </member>
    <member name="T:Ncqrs.Commanding.CommandBase">
      <summary>
            The base of a command message. A command should contain all the
            information and intend that is needed to execute an corresponding
            action.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.ICommand">
      <summary>
            A command message. A command should contain all the information and
            intend that is needed to execute an corresponding action.
            </summary>
    </member>
    <member name="P:Ncqrs.Commanding.ICommand.CommandIdentifier">
      <summary>
            Gets the unique identifier for this command.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandBase.#ctor(System.Guid)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandBase" /> class.
            This initializes the <see cref="P:Ncqrs.Commanding.CommandBase.CommandIdentifier" /> with the given
            id from <paramref name="commandIdentifier" />.
            </summary>
      <param name="commandIdentifier">The command identifier.</param>
    </member>
    <member name="M:Ncqrs.Commanding.CommandBase.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandBase" /> class.
            This initializes the <see cref="P:Ncqrs.Commanding.CommandBase.CommandIdentifier" /> with the result
            of the <see cref="T:Ncqrs.IUniqueIdentifierGenerator">generator</see> set in 
            the <see cref="T:Ncqrs.NcqrsEnvironment" />.
            </summary>
      <remarks>
            This uses the <see cref="M:Ncqrs.NcqrsEnvironment.Get``1" /> to get
            the generator to use to generate the command identifier.
            </remarks>
    </member>
    <member name="M:Ncqrs.Commanding.CommandBase.#ctor(Ncqrs.IUniqueIdentifierGenerator)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandBase" /> class. This will set
            the <see cref="P:Ncqrs.Commanding.CommandBase.CommandIdentifier" /> to a identifier value generated by the 
            <paramref name="idGenerator" />.
            </summary>
      <param name="idGenerator">The id generator. This cannot be <c>null</c>.</param>
      <requires exception="T:System.ArgumentNullException">idGenerator != null</requires>
      <exception cref="T:System.ArgumentNullException">idGenerator == null</exception>
    </member>
    <member name="P:Ncqrs.Commanding.CommandBase.CommandIdentifier">
      <summary>
            Gets the unique identifier for this command.
            </summary>
    </member>
    <member name="T:Ncqrs.Domain.Entity">
      <summary>
            The abstract concept of an entity -- an object living inside an aggregate with own thread of identity.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.PropertyBagConverter">
      <summary>
            Converts an <see cref="T:Ncqrs.Eventing.IEvent" /> from/to a flattened structure suitable for storing in an <see cref="T:Ncqrs.Eventing.Storage.IEventStore" />.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.IPropertyBagConverter">
      <summary>
            Serializes and deserializes <see cref="!:ICommand" /> and <see cref="T:Ncqrs.Eventing.IEvent" /> from/to in a binary format suitable 
            for an <see cref="T:Ncqrs.Eventing.Storage.IEventStore" />.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IPropertyBagConverter.AddPostConversion(System.Type,Ncqrs.Eventing.Storage.IPropertyBagPostConverter)">
      <summary>
            Adds a custom converter that resolves differences when deserializing an event or command with
            an earlier schema. 
            </summary>
      <param name="targetType">The type of command or event for which to a add custom post conversion.</param>
      <param name="converter">The converter object that will resolve the differences.</param>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IPropertyBagConverter.Convert(System.Object)">
      <summary>
            Converts a event into a property bag.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IPropertyBagConverter.Convert(Ncqrs.Eventing.Storage.PropertyBag)">
      <summary>
            Converts a command or event stored as a property bag back to its object representation.
            </summary>
      <remarks>
            If a post conversion was registered using <see cref="M:Ncqrs.Eventing.Storage.IPropertyBagConverter.AddPostConversion(System.Type,Ncqrs.Eventing.Storage.IPropertyBagPostConverter)" />, it will be invoked after
            the default conversion has completed. Moreover, the actual type created can be overridden by
            providing a custom <see cref="T:Ncqrs.Eventing.Storage.IEventTypeResolver" /> through the <see cref="!:TypeResolver" /> property.
            </remarks>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.PropertyBagConverter.AddPostConversion(System.Type,Ncqrs.Eventing.Storage.IPropertyBagPostConverter)">
      <summary>
            Adds a custom converter that resolves differences when converting an event or command with
            an earlier schema.
            </summary>
      <param name="targetType">The type of command or event for which to a add custom post conversion.</param>
      <param name="converter">The converter object that will resolve the differences.</param>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.PropertyBagConverter.Convert(System.Object)">
      <summary>
            Converts a command or event into a property bag.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.PropertyBagConverter.Convert(Ncqrs.Eventing.Storage.PropertyBag)">
      <summary>
            Converts a command or event stored as a property bag back to its object representation.
            </summary>
      <remarks>
            If a post conversion was registered using <see cref="M:Ncqrs.Eventing.Storage.PropertyBagConverter.AddPostConversion(System.Type,Ncqrs.Eventing.Storage.IPropertyBagPostConverter)" />, it will be invoked after
            the default conversion has completed. Moreover, the actual type created can be overridden by
            providing a custom <see cref="T:Ncqrs.Eventing.Storage.IEventTypeResolver" /> through the <see cref="P:Ncqrs.Eventing.Storage.PropertyBagConverter.TypeResolver" /> property.
            </remarks>
    </member>
    <member name="P:Ncqrs.Eventing.Storage.PropertyBagConverter.TypeResolver">
      <summary>
            Gets or sets a resolver that maps between types and event names.
            </summary>
      <remarks>
            The default implementation is to use the type's assembly qualified name.
            </remarks>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.Mapping.ExpressionBasedSourcedEventHandlerMappingStrategy">
      <summary>
            An internal event handler mapping strategy that creates event handlers based on mapping that is done by lambdas.
            <remarks>
            If u inherit from the <see cref="T:Ncqrs.Domain.AggregateRootMappedWithExpressions" /> u must implement the method
            InitializeEventHandlers(); Inside this method u can define the mapping between an event and an event source method
            in a strongly typed fashion.
            <code>
            public class Foo : AggregateRootMappedWithExpressions
            {
                public override void InitializeEventHandlers()
                {
                    Map{SomethingHappenedEvent}().ToHandler(x =&gt; SomethingHasHappened(x));
                }
                
                public void SomethingHasHappened(SourcedEvent e)
                {}
            }
            
            public class SomethingHappenedEvent : SourcedEvent
            {}
            </code></remarks></summary>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.Mapping.ExpressionBasedSourcedEventHandlerMappingStrategy.GetEventHandlersFromAggregateRoot(System.Object)">
      <summary>
            Gets the event handlers from aggregate root based on the given mapping.
            </summary>
      <param name="eventSource">The aggregate root.</param>
      <see cref="T:Ncqrs.Eventing.Sourcing.Mapping.ExpressionBasedSourcedEventHandlerMappingStrategy" />
      <returns>All the <see cref="T:Ncqrs.Eventing.Sourcing.ISourcedEventHandler" />'s created based on the given mapping.</returns>
      <requires description="The eventSource cannot be null." exception="T:System.ArgumentNullException">eventSource != null</requires>
      <exception cref="T:System.ArgumentNullException">eventSource == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.Mapping.ExpressionBasedSourcedEventHandlerMappingStrategy.CreateHandlerForMethod(System.Object,System.Reflection.MethodInfo,System.Boolean)">
      <summary>
            Converts the given method into an <see cref="T:Ncqrs.Eventing.Sourcing.ISourcedEventHandler" /> object.
            </summary>
      <param name="eventSource">The event source from which we want to invoke the method.</param>
      <param name="method">The method to invoke</param>
      <param name="exact">
        <b>True</b> if we need to have an exact match, otherwise <b>False</b>.</param>
      <returns>An <see cref="T:Ncqrs.Eventing.Sourcing.ISourcedEventHandler" /> that handles the execution of the given method.</returns>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute">
      <summary>
            Defines that the command maps directly to a constructor on an aggregate root.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute" /> class.
            </summary>
      <param name="typeName">The full qualified name of the type of the aggregate root.</param>
      <exception cref="T:System.ArgumentNullException">Thrown when <i>typeName</i> is null or emtpy.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute" /> class.
            </summary>
      <param name="type">The type of the aggregate root.</param>
      <exception cref="T:System.ArgumentNullException">Thrown when <i>type</i> is null.</exception>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute.TypeName">
      <summary>
            Get the full qualified type name of the target aggregate root.
            </summary>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootConstructorAttribute.Type">
      <summary>
            Get the type of the target aggregate root.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1">
      <summary>
            Executes a command. This means that the handles 
            executes the correct action based on the command.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1.Execute(`0)">
      <summary>
            Executes the command.
            </summary>
      <param name="command">The command to execute. This should not be null.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>command</i> is null.</exception>
    </member>
    <member name="T:Ncqrs.Eventing.ServiceModel.Bus.IEventBus">
      <summary>
            A bus that can publish events to handlers.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.IEventBus.Publish(Ncqrs.Eventing.IEvent)">
      <summary>
            Publishes the event to the handlers.
            </summary>
      <param name="eventMessage">The message to publish.</param>
      <exception cref="!:ArgumentNullException">Thrown when <i>message</i> was null.</exception>
      <exception cref="!:NoHandlerRegisteredForMessageException">Thrown when no handler was found for the specified message.</exception>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.IEventBus.Publish(System.Collections.Generic.IEnumerable{Ncqrs.Eventing.IEvent})">
      <summary>
            Publishes the messages to the handlers.
            </summary>
      <param name="eventMessage">The messages to publish.</param>
      <exception cref="!:ArgumentNullException">Thrown when <i>messages</i> was null.</exception>
      <exception cref="!:ArgumentNullException">Thrown when a instance in <i>messages</i> was null.</exception>
      <exception cref="!:NoHandlerRegisteredForMessageException">Thrown when no handler was found for one of the specified messages.</exception>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.InProcessEventBus.#ctor">
      <summary>
            Creates new <see cref="T:Ncqrs.Eventing.ServiceModel.Bus.InProcessEventBus" /> instance that wraps publishing to
            handlers into a <see cref="T:System.Transactions.TransactionScope" />.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.InProcessEventBus.#ctor(System.Boolean)">
      <summary>
            Creates new <see cref="T:Ncqrs.Eventing.ServiceModel.Bus.InProcessEventBus" /> instance.
            </summary>
      <param name="useTransactionScope">Use transaction scope?</param>
    </member>
    <member name="T:Ncqrs.InternalExtensions">
      <summary>
            Provides general extensions that are used inside the framework code.
            </summary>
    </member>
    <member name="M:Ncqrs.InternalExtensions.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Determine whether an IEnumerable source is empty or not.
            </summary>
      <typeparam name="TSource">The type of the objects that can be enumerated.</typeparam>
      <param name="source">The source to check. This may not be null.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <paramref name="source" /> is <c>null</c>.</exception>
      <returns>
        <c>true</c> whenever the source did not contain any items to enumerate; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:Ncqrs.InternalExtensions.IsNullOrEmpty(System.String)">
      <summary>
            Determines whether a string is <c>null</c> or <see cref="F:System.String.Empty" /></summary>
      <param name="source">The source to check.</param>
      <returns>
        <c>true</c> if <paramref name="source" /> is <c>null</c> or <see cref="F:System.String.Empty" />; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Ncqrs.InternalExtensions.Clone``1(System.Collections.Generic.List{``0})">
      <summary>
            Clones a list. It returns a new list with the same content.
            </summary>
      <typeparam name="T">The type of the objects in the list.</typeparam>
      <param name="source">The source to clone. This cannot be <c>null</c>.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <paramref name="source" /> is <c>null</c>.</exception>
      <returns>A new instance that contains the same elements in the same order as the source.</returns>
    </member>
    <member name="M:Ncqrs.InternalExtensions.IsNullable(System.Type)">
      <summary>
            Determines whether the specified type is nullable.
            </summary>
      <param name="type">The type.</param>
      <returns>
        <c>true</c> if the specified type is nullable; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Ncqrs.Eventing.IEvent">
      <summary>
            Represents an event.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.IEvent.EventIdentifier">
      <summary>
            Gets the unique identifier for this event.
            </summary>
      <value>A <see cref="T:System.Guid" /> that represents the unique identifier of this event.</value>
    </member>
    <member name="P:Ncqrs.Eventing.IEvent.EventTimeStamp">
      <summary>
            Gets the time stamp for this event.
            </summary>
      <value>a <see cref="T:System.DateTime" /> UTC value that represents the point
            in time where this event occurred.</value>
      <getter>
        <ensures description="The event time stamp should always be in a UTC kind.">Contract.Result&lt;DateTime&gt;().Kind == DateTimeKind.Utc</ensures>
      </getter>
    </member>
    <member name="P:Ncqrs.Eventing.IEvent.EventVersion">
      <summary>
            Gets the event version.
            </summary>
      <value>The event version.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.ISourcedEvent.EventSourceId">
      <summary>
            Gets the id of the event source that caused the event.
            </summary>
      <value>The id of the event source that caused the event.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.ISourcedEvent.EventSequence">
      <summary>
            Gets the event sequence number.
            </summary>
      <remarks>
            An sequence of events always starts with <c>0</c>. So the first event in a sequence has the <see cref="P:Ncqrs.Eventing.Sourcing.ISourcedEvent.EventSequence" /> value of <c>0</c>.
            </remarks>
      <value>A number that represents the order of where this events occurred in the sequence.</value>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootConstructor`2">
      <summary>
            Represents the creation of an aggregateroot of type <typeparamref name="TAggRoot" /> from a command of type <typeparamref name="TCommand" />.
            </summary>
      <typeparam name="TCommand">The command that triggers the creation of the aggregateroot of type <typeparamref name="TAggRoot" />.</typeparam>
      <typeparam name="TAggRoot">The aggregateroot of type <typeparamref name="TAggRoot" /> on which we executed the command.</typeparam>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootConstructor`2.#ctor(System.Func{`0,`1})">
      <summary>
            Constructor, initializes a new instance of <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootConstructor`2" />.
            </summary>
      <param name="creatorfunc">The method that is responsible for the creation of the aggregateroot.</param>
      <remarks>Marked as internal because the construction is only allowed in the framework.</remarks>
      <requires description="creatorfunc can not be null." exception="T:System.ArgumentNullException">creatorfunc != null</requires>
      <exception cref="T:System.ArgumentNullException">creatorfunc == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootConstructor`2.StoreIn(System.Action{`0,`1})">
      <summary>
            Defines an action where in the created aggregateroot can be stored.
            </summary>
      <param name="storeaggregaterootinfunc">The action that defines the storage of the created aggregateroot.</param>
      <returns>The <see cref="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1" /> which is able to execute this command.</returns>
      <requires description="storeaggregaterootinfunc can not be null." exception="T:System.ArgumentNullException">storeaggregaterootinfunc != null</requires>
      <exception cref="T:System.ArgumentNullException">storeaggregaterootinfunc == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootConstructor`2.Ncqrs#Commanding#CommandExecution#ICommandExecutor{TCommand}#Execute(`0)">
      <summary>
            Executes the command.
            </summary>
      <param name="command">The command to execute.</param>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.Mapping.NoEventHandlerAttribute">
      <summary>
            Specifies that the method is not an event handler. Use this attribute to exclude the
            method from the <see cref="!:ConventionBasedDomainSourcedEventHandlerMappingStrategy" />.
            </summary>
    </member>
    <member name="T:Ncqrs.Domain.AggregateRoot">
      <summary>
            The abstract concept of an aggregate root.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.IEventSource">
      <summary>
            An object that represents all his state changes via a sequence of events.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.IEventSource.InitializeFromHistory(System.Collections.Generic.IEnumerable{Ncqrs.Eventing.Sourcing.SourcedEvent})">
      <summary>
            Initializes from history.
            </summary>
      <param name="history">The history.</param>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.IEventSource.GetUncommittedEvents">
      <summary>
            Gets the uncommitted events.
            </summary>
      <returns />
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.IEventSource.AcceptChanges">
      <summary>
            Commits the events.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.IEventSource.EventSourceId">
      <summary>
            Gets the globally unique identifier.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.IEventSource.Version">
      <summary>
            Gets the current version of the instance as it is known in the event store.
            </summary>
      <value>An <see cref="T:System.Int64" /> representing the current version of this aggregate root.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.IEventSource.InitialVersion">
      <summary>
            Gets the initial version.
            <para>
            This represents the current version of this instance. When this instance was retrieved
            via history, it contains the version as it was at that time. For new instances this value is always 0.
            </para><para>
            The version does not change until changes are accepted via the <see cref="M:Ncqrs.Eventing.Sourcing.IEventSource.AcceptChanges" /> method.
            </para></summary>
      <value>The initial version.</value>
    </member>
    <member name="F:Ncqrs.Eventing.Sourcing.EventSource._uncommittedEvents">
      <summary>
            Holds the events that are not yet committed.
            </summary>
    </member>
    <member name="F:Ncqrs.Eventing.Sourcing.EventSource._eventHandlers">
      <summary>
            A list that contains all the event handlers.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.EventSource.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Sourcing.EventSource" /> class.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.EventSource.InitializeFromHistory(System.Collections.Generic.IEnumerable{Ncqrs.Eventing.Sourcing.SourcedEvent})">
      <summary>
            Initializes from history.
            </summary>
      <param name="history">The history.</param>
      <requires description="The history cannot be null." exception="T:System.ArgumentNullException">history != null</requires>
      <exception cref="T:System.ArgumentNullException">history == null</exception>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.EventSource.EventSourceId">
      <summary>
            Gets the globally unique identifier.
            </summary>
      <exception cref="T:System.InvalidOperationException">Thrown when setting this
            value when the version of this aggregate root is not 0 or this
            instance contains are any uncommitted events.</exception>
      <setter>
        <requires exception="T:System.InvalidOperationException">Version == 0</requires>
      </setter>
      <exception cref="T:System.InvalidOperationException">Version != 0</exception>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.EventSource.Version">
      <summary>
            Gets the current version of the instance as it is known in the event store.
            </summary>
      <value>
            An <see cref="T:System.Int64" /> representing the current version of this aggregate root.
            </value>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.EventSource.InitialVersion">
      <summary>
            Gets the initial version.
            <para>
            This represents the current version of this instance. When this instance was retrieved
            via history, it contains the version as it was at that time. For new instances this value is always 0.
            </para><para>
            The version does not change until changes are accepted via the <see cref="M:Ncqrs.Eventing.Sourcing.EventSource.AcceptChanges" /> method.
            </para></summary>
      <value>The initial version.</value>
      <setter>
        <requires exception="T:System.InvalidOperationException">Version == InitialVersion</requires>
        <requires exception="T:System.ArgumentOutOfRangeException">value &gt;= 0</requires>
      </setter>
      <exception cref="T:System.InvalidOperationException">Version != InitialVersion</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">value &lt; 0</exception>
    </member>
    <member name="E:Ncqrs.Domain.AggregateRoot.EventApplied">
      <summary>
            Occurs when an event was applied to an <see cref="T:Ncqrs.Domain.AggregateRoot" />.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.Serialization.StringEventTranslator">
      <summary>
            Translates a <see cref="T:Newtonsoft.Json.Linq.JObject" /> to a <see cref="T:System.String" /> for storage.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.Serialization.IEventTranslator`1">
      <summary>
            Translates a serialized event between an intermediate (common) format
            and a raw format for storage.
            </summary>
      <typeparam name="T">The type of the raw data.</typeparam>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.IEventTranslator`1.TranslateToCommon(Ncqrs.Eventing.Storage.StoredEvent{`0})">
      <summary>
            Translates from the raw format to the intermediate (common) format.
            </summary>
      <param name="obj">The event to translate.</param>
      <returns>
        <paramref name="obj" /> translated to the common format.</returns>
      <seealso cref="M:Ncqrs.Eventing.Storage.StoredEvent`1.Clone``1(``0)" />
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.IEventTranslator`1.TranslateToRaw(Ncqrs.Eventing.Storage.StoredEvent{Newtonsoft.Json.Linq.JObject})">
      <summary>
            Translates from the intermediate (common) format to the raw format.
            </summary>
      <param name="obj">The event to translate.</param>
      <returns>
        <paramref name="obj" /> translated to the raw format.</returns>
      <seealso cref="M:Ncqrs.Eventing.Storage.StoredEvent`1.Clone``1(``0)" />
    </member>
    <member name="T:Ncqrs.Eventing.Storage.Serialization.IEventConverter">
      <summary>
            Converts old versions of events to the latest version of that event.
            </summary>
      <seealso cref="T:Ncqrs.Eventing.Storage.Serialization.EventConverter" />
      <seealso cref="T:Ncqrs.Eventing.Storage.Serialization.NullEventConverter" />
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.IEventConverter.Upgrade(Ncqrs.Eventing.Storage.StoredEvent{Newtonsoft.Json.Linq.JObject})">
      <summary>
            Upgrades an event to the latest version.
            </summary>
      <remarks>
        <para>
            This method is responsible for determining if the event needs
            upgrading, and if so upgrading it to the latest version.
            </para>
        <para>
            Upgrading the event is handled by altering the structure and the
            data in the <see cref="T:Newtonsoft.Json.Linq.JObject" /> stored in the
            <see cref="P:Ncqrs.Eventing.Storage.StoredEvent`1.Data" /> property.
            </para>
        <para>
            If it upgrades the event to a newer version it must update the
            <see cref="!:StoredEvent&lt;T&gt;.EventVersion" /> property.
            </para>
      </remarks>
      <param name="theEvent">The event to be upgraded.</param>
      <requires description="theEvent" exception="T:System.ArgumentNullException">theEvent != null</requires>
      <exception cref="T:System.ArgumentNullException">theEvent == null</exception>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.Serialization.EventConverter">
      <summary>
            Aggregates multiple type specific event converters into a single
            <see cref="T:Ncqrs.Eventing.Storage.Serialization.IEventConverter" /></summary>
      <seealso cref="T:Ncqrs.Eventing.Storage.Serialization.NullEventConverter" />
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.EventConverter.#ctor(Ncqrs.Eventing.Storage.IEventTypeResolver)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Storage.Serialization.EventConverter" /> class with a given type resolver.
            </summary>
      <param name="typeResolver">The type resolver to use when looking up event names for a specific event type.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeResolver" /> is <value>null</value>.</exception>
      <requires description="typeResolver" exception="T:System.ArgumentNullException">typeResolver != null</requires>
      <exception cref="T:System.ArgumentNullException">typeResolver == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.EventConverter.Upgrade(Ncqrs.Eventing.Storage.StoredEvent{Newtonsoft.Json.Linq.JObject})">
      <summary>
            Upgrades an event to the latest version.
            </summary>
      <remarks>
        <para>This checks to see if an <see cref="T:Ncqrs.Eventing.Storage.Serialization.IEventConverter" /> has been added for <see cref="!:StoredEvent&lt;T&gt;.EventName" />.</para>
        <para>If there is an event converter for this event then that converter will be used to upgrade the event.</para>
        <para>If no converter has been added for this event then the event will be left un-modified.</para>
      </remarks>
      <param name="theEvent">The event to be upgraded.</param>
      <exception cref="T:System.ArgumentNullException">If <paramref name="theEvent" /> is <value>null</value>.</exception>
      <seealso cref="M:Ncqrs.Eventing.Storage.Serialization.EventConverter.AddConverter(System.Type,Ncqrs.Eventing.Storage.Serialization.IEventConverter)" />
      <requires description="theEvent" inheritedFrom="M:Ncqrs.Eventing.Storage.Serialization.IEventConverter.Upgrade(Ncqrs.Eventing.Storage.StoredEvent{Newtonsoft.Json.Linq.JObject})" inheritedFromTypeName="IEventConverter" exception="T:System.ArgumentNullException">theEvent != null</requires>
      <exception cref="T:System.ArgumentNullException">theEvent == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.EventConverter.AddConverter(System.Type,Ncqrs.Eventing.Storage.Serialization.IEventConverter)">
      <summary>
            Adds a converter for the specified event to be used when upgrading events.
            </summary>
      <remarks>
        <para>This uses the type resolver to look up the name of the event.</para>
        <para>You do not need to add a converter for every event, only those that require upgrading.
            If an event has no converter added it will be left un-modified.</para>
      </remarks>
      <param name="eventType">The event type the <paramref name="converter" /> handles.</param>
      <param name="converter">The converter for the event specified by <paramref name="eventType" />.</param>
      <exception cref="T:System.ArgumentNullException">If <paramref name="eventType" /> or <paramref name="converter" /> is <value>null</value>.</exception>
      <exception cref="T:System.ArgumentException">If a converter for <paramref name="eventType" /> has already been added.</exception>
      <requires description="eventType" exception="T:System.ArgumentNullException">eventType != null</requires>
      <exception cref="T:System.ArgumentNullException">eventType == null</exception>
      <requires description="converter" exception="T:System.ArgumentNullException">converter != null</requires>
      <exception cref="T:System.ArgumentNullException">converter == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.EventConverter.AddConverter(System.String,Ncqrs.Eventing.Storage.Serialization.IEventConverter)">
      <summary>
            Adds a converter for the specified event to be used when upgrading events.
            </summary>
      <remarks>
        <para>You do not need to add a converter for every event, only those that require upgrading.
            If an event has no converter added it will be left un-modified.</para>
      </remarks>
      <param name="eventName">The name of the event the <paramref name="converter" /> handles.</param>
      <param name="converter">The converter for the event specified by <paramref name="eventName" />.</param>
      <exception cref="T:System.ArgumentNullException">If <paramref name="eventName" /> or <paramref name="converter" /> is <value>null</value>.</exception>
      <exception cref="T:System.ArgumentException">If a converter for <paramref name="eventName" /> has already been added.</exception>
      <requires description="eventName" exception="T:System.ArgumentNullException">eventName != null</requires>
      <exception cref="T:System.ArgumentNullException">eventName == null</exception>
      <requires description="converter" exception="T:System.ArgumentNullException">converter != null</requires>
      <exception cref="T:System.ArgumentNullException">converter == null</exception>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute">
      <summary>
            Defines that the command maps directly to a method on an aggregate root.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute" /> class.
            </summary>
      <param name="typeName">Name of the type.</param>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute.#ctor(System.String,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute" /> class.
            </summary>
      <param name="typeName">Name of the type.</param>
      <param name="methodName">Name of the method.</param>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute.TypeName">
      <summary>
            Get or sets the full qualified type name of the target aggregate root.
            </summary>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute.Type">
      <summary>
            Get the type of the target aggregate root.
            </summary>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.MapsToAggregateRootMethodAttribute.MethodName">
      <summary>
            Get or sets the full qualified name of the target method. Leave this null or empty to automap the target method based on the command name.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.AttributeMappedCommandExecutor`1">
      <summary>
            A command handler that execute an action based on the mapping of a command.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.AttributeMappedCommandExecutor`1.Ncqrs#Commanding#CommandExecution#ICommandExecutor{TCommand}#Execute(`0)">
      <summary>
            Executes the command.
            </summary>
      <param name="command">The command to execute. This should not be null.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>command</i> is null.</exception>
    </member>
    <member name="T:Ncqrs.GuidCombGenerator">
      <summary>
            An <see cref="T:Ncqrs.IUniqueIdentifierGenerator" /> that generates <see cref="T:System.Guid" /> values 
            using a strategy suggested Jimmy Nilsson's 
            <a href="http://www.informit.com/articles/article.asp?p=25862">article</a>.
            </summary>
      <remarks>
            The <c>comb</c> algorithm is designed to make the use of GUIDs as Primary Keys, Foreign Keys, 
            and Indexes nearly as efficient as ints.
            </remarks>
    </member>
    <member name="T:Ncqrs.IUniqueIdentifierGenerator">
      <summary>
            Generator that generates unique identifiers.
            </summary>
    </member>
    <member name="M:Ncqrs.IUniqueIdentifierGenerator.GenerateNewId">
      <summary>
            Generates the new identifier.
            </summary>
      <returns>A new <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Ncqrs.GuidCombGenerator.GenerateNewId">
      <summary>
            Generate a new <see cref="T:System.Guid" /> using the comb algorithm.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore">
      <summary>
            Stores events for a SQL database.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.IEventStore">
      <summary>
            A event store. Can store and load events from an <see cref="T:Ncqrs.Eventing.Sourcing.IEventSource" />.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IEventStore.GetAllEvents(System.Guid)">
      <summary>
            Get all events provided by an specified event provider.
            </summary>
      <param name="id">The id of the event source that owns the events.</param>
      <returns>All the events from the event source.</returns>
      <ensures description="Result should never be null.">Contract.Result&lt;IEnumerable&lt;SourcedEvent&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IEventStore.GetAllEventsSinceVersion(System.Guid,System.Int64)">
      <summary>
            Get all events provided by an specified event source.
            </summary>
      <param name="eventSourceId">The id of the event source that owns the events.</param>
      <returns>All the events from the event source.</returns>
      <ensures>Contract.ForAll(Contract.Result&lt;IEnumerable&lt;SourcedEvent&gt;&gt;(), e =&gt; e.EventSequence &gt; version)</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IEventStore.Save(Ncqrs.Eventing.Sourcing.IEventSource)">
      <summary>
            Save all events from a specific event provider.
            </summary>
      <exception cref="T:Ncqrs.Eventing.Storage.ConcurrencyException">Occurs when there is already a newer version of the event provider stored in the event store.</exception>
      <param name="source">The source that should be saved.</param>
      <requires description="source cannot be null." exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.ISnapshotStore.SaveShapshot(Ncqrs.Eventing.Sourcing.Snapshotting.ISnapshot)">
      <summary>
            Saves a snapshot of the specified event source.
            </summary>
      <requires description="The source cannot be null." exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.ISnapshotStore.GetSnapshot(System.Guid)">
      <summary>
            Gets a snapshot of a particular event source, if one exists. Otherwise, returns <c>null</c>.
            </summary>
      <ensures>Contract.Result&lt;ISnapshot&gt;() != null ? Contract.Result&lt;ISnapshot&gt;().EventSourceId == eventSourceId : true</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore.GetAllEvents(System.Guid)">
      <summary>
            Get all event for a specific event provider.
            </summary>
      <param name="id">The id of the event provider.</param>
      <returns>All events for the specified event provider.</returns>
      <ensures description="Result should never be null." inheritedFrom="M:Ncqrs.Eventing.Storage.IEventStore.GetAllEvents(System.Guid)" inheritedFromTypeName="IEventStore">Contract.Result&lt;IEnumerable&lt;SourcedEvent&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore.GetAllEventsSinceVersion(System.Guid,System.Int64)">
      <summary>
            Get all events provided by an specified event source.
            </summary>
      <param name="eventSourceId">The id of the event source that owns the events.</param>
      <returns>All the events from the event source.</returns>
      <ensures inheritedFrom="M:Ncqrs.Eventing.Storage.IEventStore.GetAllEventsSinceVersion(System.Guid,System.Int64)" inheritedFromTypeName="IEventStore">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;SourcedEvent&gt;&gt;(), e =&gt; e.EventSequence &gt; version)</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore.Save(Ncqrs.Eventing.Sourcing.IEventSource)">
      <summary>
            Saves all events from an event provider.
            </summary>
      <param name="provider">The eventsource.</param>
      <requires description="source cannot be null." inheritedFrom="M:Ncqrs.Eventing.Storage.IEventStore.Save(Ncqrs.Eventing.Sourcing.IEventSource)" inheritedFromTypeName="IEventStore" exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore.SaveShapshot(Ncqrs.Eventing.Sourcing.Snapshotting.ISnapshot)">
      <summary>
            Saves a snapshot of the specified event source.
            </summary>
      <requires description="The source cannot be null." inheritedFrom="M:Ncqrs.Eventing.Storage.ISnapshotStore.SaveShapshot(Ncqrs.Eventing.Sourcing.Snapshotting.ISnapshot)" inheritedFromTypeName="ISnapshotStore" exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore.GetSnapshot(System.Guid)">
      <summary>
            Gets a snapshot of a particular event source, if one exists. Otherwise, returns <c>null</c>.
            </summary>
      <ensures inheritedFrom="M:Ncqrs.Eventing.Storage.ISnapshotStore.GetSnapshot(System.Guid)" inheritedFromTypeName="ISnapshotStore">Contract.Result&lt;ISnapshot&gt;() != null ? Contract.Result&lt;ISnapshot&gt;().EventSourceId == eventSourceId : true</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore.SaveEvents(System.Collections.Generic.IEnumerable{Ncqrs.Eventing.Sourcing.ISourcedEvent},System.Data.SqlClient.SqlTransaction)">
      <summary>
            Saves the events to the event store.
            </summary>
      <param name="evnts">The events to save.</param>
      <param name="eventSourceId">The event source id that owns the events.</param>
      <param name="transaction">The transaction.</param>
      <requires description="The argument evnts could not be null." exception="T:System.ArgumentNullException">evnts != null</requires>
      <exception cref="T:System.ArgumentNullException">evnts == null</exception>
      <requires description="The argument transaction could not be null." exception="T:System.ArgumentNullException">transaction != null</requires>
      <exception cref="T:System.ArgumentNullException">transaction == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore.SaveEvent(Ncqrs.Eventing.Sourcing.ISourcedEvent,System.Data.SqlClient.SqlTransaction)">
      <summary>
            Saves the event to the data store.
            </summary>
      <param name="evnt">The event to save.</param>
      <param name="eventSourceId">The id of the event source that owns the event.</param>
      <param name="transaction">The transaction.</param>
      <requires description="The argument evnt could not be null." exception="T:System.ArgumentNullException">evnt != null</requires>
      <exception cref="T:System.ArgumentNullException">evnt == null</exception>
      <requires description="The argument transaction could not be null." exception="T:System.ArgumentNullException">transaction != null</requires>
      <exception cref="T:System.ArgumentNullException">transaction == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore.AddEventSource(Ncqrs.Eventing.Sourcing.IEventSource,System.Data.SqlClient.SqlTransaction)">
      <summary>
            Adds the event source to the event store.
            </summary>
      <param name="eventSource">The event source to add.</param>
      <param name="transaction">The transaction.</param>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore.GetVersion(System.Guid,System.Data.SqlClient.SqlTransaction)">
      <summary>
            Gets the version of the provider from the event store.
            </summary>
      <param name="providerId">The provider id.</param>
      <param name="transaction">The transaction.</param>
      <returns>A <see cref="!:int?" /> that is <c>null</c> when no version was known ; otherwise,
            it contains the version number.</returns>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SQL.MsSqlServerEventStore.GetTableCreationQueries">
      <summary>
            Gets the table creation queries that can be used to create the tables that are needed
            for a database that is used as an event store.
            </summary>
      <remarks>This returns the content of the TableCreationScript.sql that is embedded as resource.</remarks>
      <returns>Queries that contain the <i>create table</i> statements.</returns>
    </member>
    <member name="T:Ncqrs.IClock">
      <summary>
            Represents a clock that can give the current time.
            </summary>
    </member>
    <member name="M:Ncqrs.IClock.UtcNow">
      <summary>
            Gets the current UTC date and time from the clock.
            </summary>
      <returns>The current UTC date and time.</returns>
      <ensures description="The result should be a UTC date and time.">Contract.Result&lt;DateTime&gt;().Kind == DateTimeKind.Utc</ensures>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.Serialization.JsonEventFormatter">
      <summary>
            Serializes events to <see cref="T:Newtonsoft.Json.Linq.JObject" />.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.Serialization.IEventFormatter`1">
      <summary>
            Serializes/deserializes strongly typed events for storage.
            </summary>
      <remarks>
        <para>
            This is generally intended to use an intermediate format such
            as <see cref="T:System.Xml.Linq.XDocument" /> or <see cref="T:Newtonsoft.Json.Linq.JObject" />
            rather than a raw string or binary blob.
            </para>
        <para>
            Using an intermediate format that is easily manipulatable allows
            for easier handling of old verisons of events (see <see cref="T:Ncqrs.Eventing.Storage.Serialization.IEventConverter" />).
            </para>
      </remarks>
      <typeparam name="T">The type of the serialized data.</typeparam>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.IEventFormatter`1.Serialize(Ncqrs.Eventing.Sourcing.ISourcedEvent)">
      <summary>
            Serializes a strongly typed event.
            </summary>
      <param name="theEvent">The event to serialize.</param>
      <returns>A serialized representation of <paramref name="theEvent" />.</returns>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.IEventFormatter`1.Deserialize(Ncqrs.Eventing.Storage.StoredEvent{`0})">
      <summary>
            De-serializes a serialized event to a strongly typed event.
            </summary>
      <param name="obj">The serialized event to be de-serialized.</param>
      <returns>A strongly typed event from <paramref name="obj" />.</returns>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.JsonEventFormatter.#ctor(Ncqrs.Eventing.Storage.IEventTypeResolver)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Storage.Serialization.JsonEventFormatter" /> class
            with a given type resolver.
            </summary>
      <param name="typeResolver">The <see cref="T:Ncqrs.Eventing.Storage.IEventTypeResolver" /> to use
            when resolving event types/names.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="typeResolver" /> is <value>null</value>.</exception>
      <requires description="typeResolver" exception="T:System.ArgumentNullException">typeResolver != null</requires>
      <exception cref="T:System.ArgumentNullException">typeResolver == null</exception>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.ISourcedEventHandler">
      <summary>
            An event handler that handles the domain events.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.ISourcedEventHandler.HandleEvent(Ncqrs.Eventing.Sourcing.SourcedEvent)">
      <summary>
            Handles the event.
            </summary>
      <param name="sourcedEvent">The event to handle.</param>
      <returns>
        <c>true</c> when the event was handled; otherwise, <c>false</c>.
            <remarks><c>false</c> does not mean that the handling failed, but that the 
            handler was not interested in handling this event.</remarks></returns>
      <requires description="The sourcedEvent cannot be null." exception="T:System.ArgumentNullException">sourcedEvent != null</requires>
      <exception cref="T:System.ArgumentNullException">sourcedEvent == null</exception>
    </member>
    <!-- Badly formed XML comment ignored for member "T:Ncqrs.Domain.AggregateRootMappedByConvention" -->
    <member name="M:Ncqrs.Domain.AggregateRootMappedByConvention.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.AggregateRootMappedByConvention" /> class.
            </summary>
    </member>
    <member name="T:Ncqrs.NcqrsEnvironmentException">
      <summary>
            Occurs when there was an exception in the Ncqrs environment configuration.
            </summary>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironmentException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.NcqrsEnvironmentException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironmentException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.NcqrsEnvironmentException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="inner">The inner.</param>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironmentException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.NcqrsEnvironmentException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="T:Ncqrs.Eventing.Event">
      <summary>
            The base for all event messages. All sourced events should subclass from <see cref="T:Ncqrs.Eventing.Sourcing.SourcedEvent" />.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Event.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Event" /> class.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.Event.EventIdentifier">
      <summary>
            Gets the unique identifier for this event.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.Event.EventTimeStamp">
      <summary>
            Gets the time stamp for this event.
            </summary>
      <value>a <see cref="T:System.DateTime" /> UTC value that represents the point
            in time where this event occurred.</value>
      <getter>
        <ensures description="The event time stamp should always be in a UTC kind." inheritedFrom="M:Ncqrs.Eventing.IEvent.get_EventTimeStamp" inheritedFromTypeName="IEvent">Contract.Result&lt;DateTime&gt;().Kind == DateTimeKind.Utc</ensures>
      </getter>
    </member>
    <member name="P:Ncqrs.Eventing.Event.EventVersion">
      <summary>
            Gets the event version.
            </summary>
      <value>The event version.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.SourcedEvent.EventSourceId">
      <summary>
            Gets the id of the event source that caused the event.
            </summary>
      <value>The id of the event source that caused the event.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.SourcedEvent.EventSequence">
      <summary>
            Gets the event sequence number.
            </summary>
      <remarks>
            An sequence of events always starts with <c>1</c>. So the first event in a sequence has the <see cref="P:Ncqrs.Eventing.Sourcing.SourcedEvent.EventSequence" /> value of <c>1</c>.
            </remarks>
      <value>A number that represents the order of where this events occurred in the sequence.</value>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.ConcurrencyException">
      <summary>
            Occurs when there is already a newer version of the event source stored in the event store.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.ConcurrencyException.#ctor(System.Guid,System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Storage.ConcurrencyException" /> class.
            </summary>
      <param name="eventSourceId">The id of the event source.</param>
      <param name="providerVersion">The event source version.</param>
      <param name="versionInStore">The version in store.</param>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.ConcurrencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Storage.ConcurrencyException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Ncqrs.Eventing.Storage.ConcurrencyException.EventSourceId">
      <summary>
            Gets the id of the event source.
            </summary>
      <value>The id event source.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Storage.ConcurrencyException.EventSourceVersion">
      <summary>
            Gets the event source version.
            </summary>
      <value>The event source version.</value>
    </member>
    <member name="M:Ncqrs.Domain.Storage.DomainRepository.GetById``1(System.Guid)">
      <summary>
            Gets aggregate root by eventSourceId.
            </summary>
      <typeparam name="T">The type of the aggregate root.</typeparam>
      <param name="eventSourceId">The eventSourceId of the aggregate root.</param>
      <exception cref="T:Ncqrs.Domain.Storage.AggregateRootNotFoundException">Occurs when the aggregate root with the 
            specified event source id could not be found.</exception>
      <returns>
            A new instance of the aggregate root that contains the latest known state.
            </returns>
    </member>
    <member name="M:Ncqrs.Domain.Storage.DomainRepository.GetById(System.Type,System.Guid)">
      <summary>
            Gets aggregate root by <see cref="!:AggregateRoot.EventSourcId">event source id</see>.
            </summary>
      <param name="aggregateRootType">Type of the aggregate root.</param>
      <param name="eventSourceId">The eventSourceId of the aggregate root.</param>
      <exception cref="T:Ncqrs.Domain.Storage.AggregateRootNotFoundException">Occurs when the aggregate root with the 
            specified event source id could not be found.</exception>
      <returns>
            A new instance of the aggregate root that contains the latest known state.
            </returns>
      <requires inheritedFrom="M:Ncqrs.Domain.Storage.IDomainRepository.GetById(System.Type,System.Guid)" inheritedFromTypeName="IDomainRepository" exception="T:System.ArgumentNullException">aggregateRootType != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRootType == null</exception>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.Mapping.AttributeBasedSourcedEventHandlerMappingStrategy">
      <summary>
            An internal event handler mapping strategy that creates event handlers based on mapping that
            is done by attributes.
            <remarks>Use the <see cref="T:Ncqrs.Eventing.Sourcing.Mapping.EventHandlerAttribute" /> to mark event handler methods as an event handler. You can only
            mark methods that following rules:
            <list type="number"><item><description>The method should be an instance method (no static).</description></item><item><description>It should accept 1 parameter.</description></item><item><description>The parameter should be, or inherited from, the <see cref="T:Ncqrs.Eventing.Sourcing.SourcedEvent" /> class.</description></item><item><description>The method should be marked with the <see cref="T:Ncqrs.Eventing.Sourcing.Mapping.EventHandlerAttribute" />.</description></item></list><code>public class Foo : AggregateRootMappedWithAttributes
            {
                [EventHandler]
                private void onFooEvent(FooEvent eventToHandle)
                {
                    // ...
                }
            }</code></remarks></summary>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.Mapping.AttributeBasedSourcedEventHandlerMappingStrategy.GetEventHandlersFromAggregateRoot(System.Object)">
      <summary>
            Gets the event handlers from aggregate root based on attributes.
            </summary>
      <param name="eventSource">The aggregate root.</param>
      <see cref="T:Ncqrs.Eventing.Sourcing.Mapping.AttributeBasedSourcedEventHandlerMappingStrategy" />
      <returns>All the <see cref="!:IDomainEventHandler" />'s created based on attribute mapping.</returns>
      <requires description="The eventSource cannot be null." exception="T:System.ArgumentNullException">eventSource != null</requires>
      <exception cref="T:System.ArgumentNullException">eventSource == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.PropertyBag.#ctor(System.String)">
      <summary>
              Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.PropertyBag.AddPropertyValue(System.String,System.Object)">
      <summary>
            Adds a property value to this bag.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="value">The value.</param>
    </member>
    <member name="P:Ncqrs.Eventing.Storage.PropertyBag.EventName">
      <summary>
              Gets or sets the event name of the original object from which this document was constructed.
            </summary>
    </member>
    <member name="P:Ncqrs.Eventing.Storage.PropertyBag.Properties">
      <summary>
              Gets or sets the names and values of all public properties of the original object.
            </summary>
    </member>
    <member name="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException">
      <summary>
            Occurs when a requested instance could not be found in the Ncqrs environment configuration.
            </summary>
    </member>
    <member name="M:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException" /> class.
            </summary>
      <param name="requestedType">Type of the requested instance.</param>
    </member>
    <member name="M:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException.#ctor(System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException" /> class.
            </summary>
      <param name="requestedType">Type of the requested instance.</param>
      <param name="message">The message.</param>
    </member>
    <member name="M:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException.#ctor(System.Type,System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException" /> class.
            </summary>
      <param name="requestedType">Type of the requested instance.</param>
      <param name="message">The message.</param>
      <param name="inner">The inner exception.</param>
    </member>
    <member name="M:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException.RequestedType">
      <summary>
            Gets the type of the requested instance.
            </summary>
      <value>The type of the requested instance.</value>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`1">
      <summary>
            Represents the base mapping of a command.
            </summary>
      <typeparam name="TCommand">The mapped command to be executed for for the aggregateroot.</typeparam>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`1.Execute(`0)">
      <summary>
            Executes the given command of type <typeparamref name="TCommand" /> for the mapped aggregateroot.
            </summary>
      <param name="command">The <see cref="!:TCommand" /> to execute.</param>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`2">
      <summary>
            Represents a mapping between the command type <typeparamref name="TCommand" /> and the aggregateroot type <typeparamref name="TAggRoot" />.
            </summary>
      <typeparam name="TCommand">The mapped command to be executed for for the aggregateroot.</typeparam>
      <typeparam name="TAggRoot">The aggregateroot in which we will execute the given command.</typeparam>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`2.#ctor">
      <summary>
            Constructor, initializes a new instance of <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`2" />.
            </summary>
      <remarks>Marked as internal because the construction is only allowed in the framework.</remarks>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`2.Execute(`0)">
      <summary>
            Executes the given command of type <typeparamref name="TCommand" /> for the mapped aggregateroot.
            </summary>
      <param name="command">The <see cref="!:TCommand" /> to execute.</param>
      <requires description="command can not be null." exception="T:System.ArgumentNullException">command != null</requires>
      <exception cref="T:System.ArgumentNullException">command == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`2.WithId(System.Func{`0,System.Guid})">
      <summary>
            Creates a <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2" /> which represents the method that is to be 
            called on the aggregateroot of type <typeparamref name="TAggRoot" /></summary>
      <param name="getidfromcommandfunc">The method responsible for retrieving the id of the aggregateroot from the command.</param>
      <returns>A <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2" />.</returns>
      <requires description="getidfromcommandfunc can not be null." exception="T:System.ArgumentNullException">getidfromcommandfunc != null</requires>
      <exception cref="T:System.ArgumentNullException">getidfromcommandfunc == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`2.WithId(System.Func{`0,System.Guid},System.Func{System.Guid,`1})">
      <summary>
            Creates a <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2" /> which represents the method that is to be called 
            on the aggregateroot of type <typeparamref name="TAggRoot" />.
            </summary>
      <param name="getidfromcommandfunc">The method responsible for retrieving the id of the aggregateroot from the command.</param>
      <param name="getaggregaterootfunc">The method responsible for retrieving the aggregateroot of type <typeparamref name="TAggRoot" /> from a <see cref="T:System.Guid" />.</param>
      <returns>A <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2" />.</returns>
      <requires description="getidfromcommandfunc can not be null." exception="T:System.ArgumentNullException">getidfromcommandfunc != null</requires>
      <exception cref="T:System.ArgumentNullException">getidfromcommandfunc == null</exception>
      <requires description="getaggregaterootfunc can not be null." exception="T:System.ArgumentNullException">getaggregaterootfunc != null</requires>
      <exception cref="T:System.ArgumentNullException">getaggregaterootfunc == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`2.CreateNew(System.Func{`0,`1})">
      <summary>
            Creates a <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootConstructor`2" /> which represents the creation of 
            an aggregateroot of type <typeparamref name="TAggRoot" />.
            </summary>
      <param name="aggregaterootcreatorfunc">The method responsible for creating the aggregateroot of type <typeparamref name="TAggRoot" />.</param>
      <returns>A <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootConstructor`2" />.</returns>
      <requires description="aggregaterootcreatorfunc can not be null." exception="T:System.ArgumentNullException">aggregaterootcreatorfunc != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregaterootcreatorfunc == null</exception>
    </member>
    <member name="T:Ncqrs.BasicGuidGenerator">
      <summary>
            An unique identifier generator based on the .NET <see cref="T:System.Guid" /> class.
            </summary>
    </member>
    <member name="M:Ncqrs.BasicGuidGenerator.GenerateNewId">
      <summary>
            Generates a new <see cref="T:System.Guid" /> based on the <see cref="M:System.Guid.NewGuid" /> method.
            </summary>
      <returns>A new generated <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="T:Ncqrs.NamespaceDoc">
      <summary>
            This namespace contains the components of the Ncqrs framework. The framework is devided in tree main sections. 
            <para><b>Commanding</b> is the section where everything related to commands, command execution and command services can be found.
            </para><para><b>Domain</b> is the section where everything related to the domain can be found. In this section you find things like
            <see cref="!:AggregateRoot" /> and the <see cref="!:IDomainRepository" />.
            </para><para><b>Eventing</b> is the section where everything related to events, denormalization and event services can be found.
            </para><para>For more information about the framework, visit <seealso cref="!:http://ncqrs.org">ncqrs.org</seealso> or visit the 
            <seealso cref="!:http://blog.ncqrs.org">blog</seealso>.</para></summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.TransactionalCommandExecutorWrapper`1">
      <summary>
            Wraps transactional behavior around the execution of command executor.
            </summary>
      <remarks>
            The transaction logic uses <c>TransactionScope</c> of the .NET framework.
            </remarks>
    </member>
    <member name="F:Ncqrs.Commanding.CommandExecution.TransactionalCommandExecutorWrapper`1._executor">
      <summary>
            The executor to use to execute the command.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.TransactionalCommandExecutorWrapper`1.#ctor(Ncqrs.Commanding.CommandExecution.ICommandExecutor{`0})">
      <summary>
            Initializes a new instance of the <see cref="!:TransactionalCommandExecutorWrapper" /> class.
            </summary>
      <param name="executor">The executor to use to execute the command.</param>
      <requires description="The executor cannot be null." exception="T:System.ArgumentNullException">executor != null</requires>
      <exception cref="T:System.ArgumentNullException">executor == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.TransactionalCommandExecutorWrapper`1.Execute(`0)">
      <summary>
            Executes the command within a transaction. The transaction logic uses TransactionScope.
            </summary>
      <param name="command">The command to execute. This should not be null.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>command</i> is null.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandService.Execute(Ncqrs.Commanding.ICommand)">
      <summary>
            Execute a <see cref="T:Ncqrs.Commanding.ICommand" /> by giving it to the registered <see cref="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1" />.
            </summary>
      <param name="command">The command to execute.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when the <i>command</i> was a <c>null</c> dereference.</exception>
      <exception cref="T:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException">Occurs when the <see cref="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1" /> was not found for on the given <see cref="T:Ncqrs.Commanding.ICommand" />.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandService.RegisterExecutor``1(Ncqrs.Commanding.CommandExecution.ICommandExecutor{``0})">
      <summary>
            Registers the executor for the specified command type. The executor will be called for every command of the specified type.
            </summary>
      <typeparam name="TCommand">The type of the command.</typeparam>
      <param name="executor">The executor that will be called for every command of the specified type.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when the <i>commandType</i> or <i>executor</i> was a <c>null</c> dereference.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandService.UnregisterExecutor``1">
      <summary>
            Unregisters the executor of the specified command type. The executor will not be called any more.
            </summary>
      <param name="executor">The executor to unregister.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when the <i>commandType</i> or <i>executor</i> was a <c>null</c> dereference.</exception>
      <exception cref="T:System.InvalidOperationException">Occurs when the <i>executor</i> is not the same as the registered executor for the specified command type.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandService.GetCommandExecutorForCommand(System.Type)">
      <summary>
            Gets the command executor for command.
            </summary>
      <param name="commandType">Type of the command.</param>
      <returns>
            A command executor to use to execute the command or <c>null</c> if not found.
            </returns>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandService.AddInterceptor(Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor)">
      <summary>
            Adds the interceptor. The interceptor will be called on every
            command execution.
            </summary>
      <remarks>
            When the interceptor was already added to this command service, it
            is skipped. That means that it is not added twice.
            </remarks>
      <param name="interceptor">The interceptor to add.</param>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandService.RemoveInterceptor(Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor)">
      <summary>
            Removes the interceptor. The interceptor will not be called anymore.
            </summary>
      <param name="interceptor">The interceptor to remove.</param>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException">
      <summary>
            Occurs when the mapping of a command is invalid.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException" /> class with a specified error message.
            </summary>
      <param name="message">The message that describes the error. </param>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException" /> class with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception. </param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified. </param>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.CommandMappingException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown. </param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination. </param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.ICommandExecutorExtensions">
      <summary>
            Defines an easy to use extension method for the <see cref="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1" /> interface.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.ICommandExecutorExtensions.RegisterWith``1(Ncqrs.Commanding.CommandExecution.ICommandExecutor{``0},Ncqrs.Commanding.ServiceModel.CommandService)">
      <summary>
            Registers the executor to the <see cref="T:Ncqrs.Commanding.ServiceModel.CommandService" /> service.
            </summary>
      <typeparam name="TCommand">The type of command to register to the service.</typeparam>
      <param name="executor">The executor to register with the command.</param>
      <param name="service">The service on which we want to register the executor.</param>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.IPropertyBagPostConverter">
      <summary>
            Represents a custom conversion that resolves differences when deserializing an event or command with
            an earlier schema. 
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IPropertyBagPostConverter.ApplyConversion(System.Object,System.Type,System.Collections.Generic.IDictionary{System.String,System.Object})">
      <summary>
            Is called after the deserialization process of the <see cref="T:Ncqrs.Eventing.Storage.IPropertyBagConverter" /> has completed
            and should be used to resolve differences between earlier versions of a command or event.
            </summary>
      <param name="target">
            A deserialized object.
            </param>
      <param name="propertyData">
            The names and values of the properties of the object when it was serialized. It may include properties
            no more available on the current version of the object.
            </param>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.ParameterAttribute">
      <summary>
            Specifies the parameter information of where the command property
            maps to. This can be either by ordinal or by name. Where if ordinal 
            is used, name will be ignored.
            </summary>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.ParameterAttribute.Ordinal">
      <summary>
            Gets the ordinal of the parameter that is used. The ordinal numbers start by one (<c>1</c>).
            </summary>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.ParameterAttribute.Name">
      <summary>
            Gets the name of the parameter that the property maps to.
            </summary>
      <remarks>If <see cref="P:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.ParameterAttribute.Ordinal" /> is set, this will be ignored.</remarks>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.CreatingCommandExecutor`2">
      <summary>
            A command executor that creates a <typeparamref name="TAggregateRoot" />. The creation
            result will be added to the context and accepted at the end of the <see cref="M:Ncqrs.Commanding.CommandExecution.CreatingCommandExecutor`2.Execute(`0)" /> method.
            </summary>
      <typeparam name="TCommand">The command to execute.</typeparam>
      <typeparam name="TAggregateRoot">The type of the object to create.</typeparam>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.CreatingCommandExecutor`2.#ctor(System.Func{`0,`1})">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.CreatingCommandExecutor`2" /> class.
            </summary>
      <param name="create">The create func that creates the object based on the command.</param>
      <requires description="The action cannot be null." exception="T:System.ArgumentNullException">create != null</requires>
      <exception cref="T:System.ArgumentNullException">create == null</exception>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.InMemoryEventStore">
      <summary>
            An in memory event store that can be used for unit testing purpose. We can't
            think of any situation where you want to use this in production.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.InMemoryEventStore.GetAllEventsSinceVersion(System.Guid,System.Int64)">
      <summary>
            Get all events provided by an specified event source.
            </summary>
      <param name="eventSourceId">The id of the event source that owns the events.</param>
      <returns>All the events from the event source.</returns>
      <ensures inheritedFrom="M:Ncqrs.Eventing.Storage.IEventStore.GetAllEventsSinceVersion(System.Guid,System.Int64)" inheritedFromTypeName="IEventStore">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;SourcedEvent&gt;&gt;(), e =&gt; e.EventSequence &gt; version)</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.InMemoryEventStore.SaveShapshot(Ncqrs.Eventing.Sourcing.Snapshotting.ISnapshot)">
      <summary>
            Saves a snapshot of the specified event source.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.InMemoryEventStore.GetSnapshot(System.Guid)">
      <summary>
            Gets a snapshot of a particular event source, if one exists. Otherwise, returns <c>null</c>.
            </summary>
    </member>
    <member name="T:Ncqrs.NcqrsEnvironment">
      <summary>The Ncqrs environment. This class gives access to other components registered in this environment.
            <remarks>
            Make sure to call the <see cref="M:Ncqrs.NcqrsEnvironment.Configure(Ncqrs.Config.IEnvironmentConfiguration)" /> method before doing anything else with this class.
            </remarks></summary>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.InitDefaults">
      <summary>
            Initialize defaults with default components.
            </summary>
    </member>
    <member name="F:Ncqrs.NcqrsEnvironment._defaults">
      <summary>
            Holds the defaults for requested types that are not configured.
            </summary>
      <remarks>
            Use the <see cref="M:Ncqrs.NcqrsEnvironment.SetDefault``1(``0)" /> method to set a default.
            </remarks>
    </member>
    <member name="F:Ncqrs.NcqrsEnvironment._instance">
      <summary>
            Hold the environment configuration. This is initialized by the <see cref="M:Ncqrs.NcqrsEnvironment.Configure(Ncqrs.Config.IEnvironmentConfiguration)" /> method.
            </summary>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.Get``1">
      <summary>
            Gets or create the requested instance specified by the parameter <typeparamref name="T" />.
            </summary>
      <remarks>This</remarks>
      <typeparam name="T">The type of the instance that is requested.
            </typeparam>
      <returns>If the type specified by <typeparamref name="T" /> is
            registered, it returns an instance that is, is a super class of, or
            implements the type specified by <typeparamref name="T" />. Otherwise
            a <see cref="T:Ncqrs.Config.InstanceNotFoundInEnvironmentConfigurationException" />
            occurs.
            </returns>
      <ensures description="The result cannot be null.">Contract.Result&lt;T&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.SetDefault``1(``0)">
      <summary>
            Sets the default for an type. This default instance is returned when
            the configured <see cref="T:Ncqrs.Config.IEnvironmentConfiguration" /> did not
            returned an instance for this type.
            </summary>
      <remarks>When the type already contains a default, it is overridden.
            </remarks>
      <typeparam name="T">The type of the instance to set a default.
            </typeparam>
      <param name="instance">The instance to set as default.</param>
      <requires description="The instance cannot be null." exception="T:System.ArgumentNullException">instance != null</requires>
      <exception cref="T:System.ArgumentNullException">instance == null</exception>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.RemoveDefault``1">
      <summary>
            Removes the default for specified type.
            </summary>
      <remarks>When there is no default set, this action is ignored.</remarks>
      <typeparam name="T">The registered default type.</typeparam>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.Configure(Ncqrs.Config.IEnvironmentConfiguration)">
      <summary>
            Configures the Ncqrs environment.
            </summary>
      <param name="source">The source that contains the configuration for the current environment.</param>
      <requires description="The source cannot be null." exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
      <requires description="Cannot configure the environment when it is already configured." exception="T:System.InvalidOperationException">!IsConfigured</requires>
      <exception cref="T:System.InvalidOperationException">IsConfigured</exception>
      <ensures description="The given source should initialize the _instance member.">_instance == source</ensures>
      <ensures description="The given source should configure this environment.">IsConfigured</ensures>
    </member>
    <member name="M:Ncqrs.NcqrsEnvironment.Deconfigure">
      <summary>
            When the environment is configured it removes the configuration. Defaults are not removed.
            </summary>
    </member>
    <member name="P:Ncqrs.NcqrsEnvironment.IsConfigured">
      <summary>
            Gets a value indicating whether this environment is configured.
            </summary>
      <value>
        <c>true</c> if this environment is configured; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.IEventTypeResolver">
      <summary>
             Resolves types for event names.
             </summary>
      <remarks>
             This is used to avoid reliance upon implementation specific names that can change
             due to refactoring such as class names and assembly names.
            
             Instead when used with <see cref="T:Ncqrs.Eventing.Storage.AttributeEventTypeResolver" /> or a custom implementation
             it can allow for event names that are more appropriate outside the application (e.g. perhaps
             you have an event directory for all your SOA services with a common naming schema).
             </remarks>
      <seealso cref="T:Ncqrs.Eventing.Storage.AttributeEventTypeResolver" />
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IEventTypeResolver.ResolveType(System.String)">
      <summary>
            Resolves the type for a specified event name.
            </summary>
      <param name="eventName">The event name to find the type for.</param>
      <returns>The type for the event.</returns>
      <remarks>
            This is used when loading an event from the event store to find the concrete type
            for a given event based upon its name.
            
            If the event will be converted by <see cref="M:Ncqrs.Eventing.Storage.IPropertyBagConverter.Convert(Ncqrs.Eventing.Storage.PropertyBag)" /> then this
            would be the final type that the converter returns, i.e. the target type registered with
            <see cref="M:Ncqrs.Eventing.Storage.IPropertyBagConverter.AddPostConversion(System.Type,Ncqrs.Eventing.Storage.IPropertyBagPostConverter)" />.
            </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="eventName" /> is <value>null</value>.</exception>
      <requires>eventName != null</requires>
      <ensures>Contract.Result&lt;Type&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.IEventTypeResolver.EventNameFor(System.Type)">
      <summary>
            Gets the event name for a given event type.
            </summary>
      <param name="type">The event's type to get the name of.</param>
      <returns>The event type's name.</returns>
      <remarks>
            This name will be used when storing the event and used with <see cref="M:Ncqrs.Eventing.Storage.IEventTypeResolver.ResolveType(System.String)" />
            when loading the event.
            </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="type" /> is <value>null</value>.</exception>
      <requires>type != null</requires>
      <ensures>Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="T:Ncqrs.Domain.IUnitOfWorkContext">
      <summary>
            All changes that will be made within this context are tracked and can be accepted or discarded.
            To accept the changes call the <see cref="M:Ncqrs.Domain.IUnitOfWorkContext.Accept" /> method before <see cref="M:System.IDisposable.Dispose" />.
            To discard the changes simply call <see cref="M:System.IDisposable.Dispose" />.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.IUnitOfWorkContext.GetById``1(System.Guid)">
      <summary>
            Gets aggregate root by eventSourceId.
            </summary>
      <typeparam name="TAggregateRoot">The type of the aggregate root.</typeparam>
      <param name="eventSourceId">The eventSourceId of the aggregate root.</param>
      <exception cref="!:AggregateRootNotFoundException">Occurs when the aggregate root with the 
            specified event source id could not be found.</exception>
      <returns>
            A new instance of the aggregate root that contains the latest known state.
            </returns>
    </member>
    <member name="M:Ncqrs.Domain.IUnitOfWorkContext.GetById(System.Type,System.Guid)">
      <summary>
            Gets aggregate root by <see cref="!:AggregateRoot.EventSourcId">event source id</see>.
            </summary>
      <param name="aggregateRootType">Type of the aggregate root.</param>
      <param name="eventSourceId">The eventSourceId of the aggregate root.</param>
      <exception cref="!:AggregateRootNotFoundException">Occurs when the aggregate root with the 
            specified event source id could not be found.</exception>
      <returns>
            A new instance of the aggregate root that contains the latest known state.
            </returns>
    </member>
    <member name="M:Ncqrs.Domain.IUnitOfWorkContext.Accept">
      <summary>
            Accept all the changes that has been made within this context. All <see cref="!:IEvent">events</see>
            that has been occured will be stored and published.
            </summary>
    </member>
    <member name="F:Ncqrs.Domain.UnitOfWork._threadInstance">
      <summary>
            The <see cref="T:Ncqrs.Domain.UnitOfWork" /> that is associated with the current thread.
            </summary>
    </member>
    <member name="F:Ncqrs.Domain.UnitOfWork._dirtyInstances">
      <summary>
            A queue that holds a reference to all instances that have themself registered as a dirty instance during the lifespan of this unit of work instance.
            </summary>
    </member>
    <member name="F:Ncqrs.Domain.UnitOfWork._repository">
      <summary>
            A reference to the repository that is associated with this instance.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.#ctor(Ncqrs.Domain.Storage.IDomainRepository)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.UnitOfWork" /> class.
            </summary>
      <param name="domainRepository">The domain repository to use in this unit of work.</param>
      <requires description="An other UnitOfWork instance already exists in this context." exception="T:System.InvalidOperationException">Current == null</requires>
      <exception cref="T:System.InvalidOperationException">Current != null</exception>
      <requires exception="T:System.ArgumentNullException">domainRepository != null</requires>
      <exception cref="T:System.ArgumentNullException">domainRepository == null</exception>
      <ensures description="The _repository member should be initialized with the one given by the domainRepository parameter.">_repository == domainRepository</ensures>
      <ensures description="The _threadInstance member should be initialized with this instance.">_threadInstance == this</ensures>
      <ensures>IsDisposed == false</ensures>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.Finalize">
      <summary>
            Releases unmanaged resources and performs other cleanup operations before the
            <see cref="T:Ncqrs.Domain.UnitOfWork" /> is reclaimed by garbage collection.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.Dispose">
      <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
      <ensures>IsDisposed == true</ensures>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
      <ensures>IsDisposed == true</ensures>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.GetById``1(System.Guid)">
      <summary>
            Gets aggregate root by eventSourceId.
            </summary>
      <typeparam name="TAggregateRoot">The type of the aggregate root.</typeparam>
      <param name="eventSourceId">The eventSourceId of the aggregate root.</param>
      <returns>
            A new instance of the aggregate root that contains the latest known state.
            </returns>
      <exception cref="T:Ncqrs.Domain.Storage.AggregateRootNotFoundException">Occurs when the aggregate root with the
            specified event source id could not be found.</exception>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.GetById(System.Type,System.Guid)">
      <summary>
            Gets aggregate root by <see cref="!:AggregateRoot.EventSourcId">event source id</see>.
            </summary>
      <param name="aggregateRootType">Type of the aggregate root.</param>
      <param name="eventSourceId">The eventSourceId of the aggregate root.</param>
      <returns>
            A new instance of the aggregate root that contains the latest known state.
            </returns>
      <exception cref="T:Ncqrs.Domain.Storage.AggregateRootNotFoundException">Occurs when the aggregate root with the
            specified event source id could not be found.</exception>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.RegisterDirtyInstance(Ncqrs.Domain.AggregateRoot)">
      <summary>
            Registers the dirty.
            </summary>
      <param name="dirtyInstance">The dirty instance.</param>
      <requires description="dirtyInstance could not be null." exception="T:System.ArgumentNullException">dirtyInstance != null</requires>
      <exception cref="T:System.ArgumentNullException">dirtyInstance == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.UnitOfWork.Accept">
      <summary>
            Accepts the unit of work and persist the changes.
            </summary>
      <requires exception="T:System.ObjectDisposedException">!IsDisposed</requires>
      <exception cref="T:System.ObjectDisposedException">IsDisposed</exception>
    </member>
    <member name="P:Ncqrs.Domain.UnitOfWork.Current">
      <summary>
            Gets the <see cref="T:Ncqrs.Domain.UnitOfWork" /> associated with the current thread context.
            </summary>
      <value>The current.</value>
    </member>
    <member name="P:Ncqrs.Domain.UnitOfWork.IsDisposed">
      <summary>
            Gets or sets a value indicating whether this instance is disposed.
            </summary>
      <value>
        <c>true</c> if this instance is disposed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Ncqrs.Domain.UnitOfWork.Repository">
      <summary>
            Gets the domain repository.
            </summary>
      <value>The domain repository.</value>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.AttributeEventTypeResolver">
      <summary>
            This resolves event using attributes to specify their names.
            </summary>
      <remarks>
            This uses <see cref="T:Ncqrs.Eventing.Storage.EventNameAttribute" /> and <see cref="T:Ncqrs.Eventing.Storage.EventNameAliasAttribute" /> to determine
            an event's name.
            
            All events must first be registered with this resolver using <see cref="M:Ncqrs.Eventing.Storage.AttributeEventTypeResolver.AddEvent(System.Type)" /> or
            <see cref="M:Ncqrs.Eventing.Storage.AttributeEventTypeResolver.AddAllEventsInAssembly(System.Reflection.Assembly)" />.
            
            All registered events must have an <see cref="T:Ncqrs.Eventing.Storage.EventNameAttribute" />. If an event has had its
            name changed at some point it can also have multiple <see cref="T:Ncqrs.Eventing.Storage.EventNameAliasAttribute" />s to allow
            deserilization of events using an previous name.
            </remarks>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.AttributeEventTypeResolver.AddEvent(System.Type)">
      <summary>
            Adds the specified type to the resolver.
            </summary>
      <param name="type">The type to add.</param>
      <remarks>
            This will use the attributes <see cref="T:Ncqrs.Eventing.Storage.EventNameAttribute" /> and <see cref="T:Ncqrs.Eventing.Storage.EventNameAliasAttribute" />
            to determine the event's name.
            </remarks>
      <exception cref="T:System.ArgumentNullException">If <paramref name="type" /> is <value>null</value>.</exception>
      <exception cref="T:System.ArgumentException">
            If <paramref name="type" /> does not inherit <see cref="T:Ncqrs.Eventing.IEvent" />
            
            or
            
            <paramref name="type" /> does not have an <see cref="T:Ncqrs.Eventing.Storage.EventNameAttribute" />
            
            or
            
            another event type is already registered using <paramref name="type" />'s name (<see cref="T:Ncqrs.Eventing.Storage.EventNameAttribute" />)
            
            or
            
            another event type is already registered using one of <paramref name="type" />'s aliases (<see cref="T:Ncqrs.Eventing.Storage.EventNameAliasAttribute" />)
            </exception>
      <requires description="type cannot be null" exception="T:System.ArgumentNullException">type != null</requires>
      <exception cref="T:System.ArgumentNullException">type == null</exception>
      <requires description="type must inherit IEvent" exception="T:System.ArgumentException">typeof(IEvent).IsAssignableFrom(type)</requires>
      <exception cref="T:System.ArgumentException">!(typeof(IEvent).IsAssignableFrom(type))</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.AttributeEventTypeResolver.AddAllEventsInAssembly(System.Reflection.Assembly)">
      <summary>
            This will add all the public <see cref="T:Ncqrs.Eventing.IEvent" />s in a given assembly.
            </summary>
      <param name="assembly">The assembly to search for <see cref="T:Ncqrs.Eventing.IEvent" />s</param>
      <exception cref="T:System.ArgumentException">
            If any of the types do not not have an <see cref="T:Ncqrs.Eventing.Storage.EventNameAttribute" />
            
            or
            
            more than one event has the same name (<see cref="T:Ncqrs.Eventing.Storage.EventNameAttribute" />)
            
            or
            
            an event has an alias that is used by another event (<see cref="T:Ncqrs.Eventing.Storage.EventNameAliasAttribute" />)
            </exception>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.EventNameAttribute">
      <summary>
             This specifies the name of an event.
            </summary>
      <remarks>
             This attribute is NOT inherited as each each event type MUST have a different name (this includes aliases).
             
             This name is used when serializing and de-serializing an event.
             </remarks>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.EventNameAliasAttribute">
      <summary>
             This specifies an alias for an event.
            </summary>
      <remarks>
             This attribute is NOT inherited as each each event type MUST have a different name (this includes aliases).
             
             This name is only used when de-serializing an event.
             </remarks>
    </member>
    <member name="T:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException">
      <summary>
            Thrown when a <see cref="!:IUnitOfWork" /> is requested but was not available in the context.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException" /> class.
            </summary>
    </member>
    <member name="M:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException" /> class.
            </summary>
      <param name="message">The message.</param>
    </member>
    <member name="M:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="inner">The inner exception.</param>
    </member>
    <member name="M:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Domain.NoUnitOfWorkAvailableInThisContextException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">
            The <paramref name="info" /> parameter is null.
            </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">
            The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0).
            </exception>
    </member>
    <member name="T:Ncqrs.Domain.AggregateRootMappedWithExpressions">
      <summary>
            A aggregate root that uses lambda style mapping to map internal event handlers. The following method should be mapped 
            </summary>
      <remarks>
            This aggregate root uses the  <see cref="T:Ncqrs.Eventing.Sourcing.Mapping.ExpressionBasedSourcedEventHandlerMappingStrategy" /> to get the internal event handlers.
            </remarks>
      <seealso cref="T:Ncqrs.Eventing.Sourcing.Mapping.ExpressionBasedSourcedEventHandlerMappingStrategy" />
    </member>
    <member name="M:Ncqrs.Domain.AggregateRootMappedWithExpressions.Map``1">
      <summary>
            Maps the given generic eventtype to the expressed handler.
            </summary>
      <typeparam name="T">This should always be a <see cref="T:Ncqrs.Eventing.Sourcing.SourcedEvent" />.</typeparam>
      <returns>An <see cref="T:Ncqrs.Eventing.Sourcing.Mapping.ExpressionHandler`1" />which allows us to define the mapping to a handler.</returns>
    </member>
    <member name="M:Ncqrs.Domain.AggregateRootMappedWithExpressions.InitializeEventHandlers">
      <summary>
             Defines the method that derived types need to implement to support strongly typed mapping.
            </summary>
    </member>
    <member name="P:Ncqrs.Domain.AggregateRootMappedWithExpressions.MappingHandlers">
      <summary>
            Gets the <see cref="T:System.Collections.Generic.IList`1" /> list of mapping rules.
            </summary>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException">
      <summary>
            Occurs when no executor was not found to execute the command.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException" /> class.
            </summary>
      <param name="commandType">Type of the command.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>commandType</i> is a <c>null</c> dereference.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException.#ctor(System.Type,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException" /> class.
            </summary>
      <param name="commandType">Type of the command.</param>
      <param name="message">The message.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>commandType</i> is a <c>null</c> dereference.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException.#ctor(System.Type,System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException" /> class.
            </summary>
      <param name="commandType">Type of the command.</param>
      <param name="message">The message.</param>
      <param name="inner">The inner exception.</param>
      <exception cref="T:System.ArgumentNullException">Occurs when <i>commandType</i> is a <c>null</c> dereference.</exception>
      <requires exception="T:System.ArgumentNullException">commandType != null</requires>
      <exception cref="T:System.ArgumentNullException">commandType == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.ExecutorForCommandNotFoundException.CommandType">
      <summary>
            Gets the type of the command.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.ServiceModel.Bus.CompositeEventBus">
      <summary>
        <see cref="T:Ncqrs.Eventing.ServiceModel.Bus.IEventBus" /> implementation wrapping serveral other event buses.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.CompositeEventBus.AddBus(Ncqrs.Eventing.ServiceModel.Bus.IEventBus)">
      <summary>
            Adds a bus to the list of buses.
            </summary>
      <param name="bus">A bus to be added.</param>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.CompositeEventBus.RemoveBus(Ncqrs.Eventing.ServiceModel.Bus.IEventBus)">
      <summary>
            Removes a bus from the list of buses.
            </summary>
      <param name="bus">A bus to be removed.</param>
    </member>
    <member name="T:Ncqrs.DateTimeBasedClock">
      <summary>
            A clock that is based on the <see cref="T:System.DateTime" /> class from the .NET framework.
            </summary>
    </member>
    <member name="M:Ncqrs.DateTimeBasedClock.UtcNow">
      <summary>
            Gets the current UTC date and time from the clock.
            </summary>
      <returns>The current UTC date and time.</returns>
      <ensures description="The result should be a UTC date and time." inheritedFrom="M:Ncqrs.IClock.UtcNow" inheritedFromTypeName="IClock">Contract.Result&lt;DateTime&gt;().Kind == DateTimeKind.Utc</ensures>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.CommandExecutorBase`1">
      <summary>
             Represents a command executor.
             </summary>
      <code lang="c#">
             public class AddProductToShoppingCartExecutor : CommandExecutorBase
             {
                 protected override void ExecuteInContext(IUnitOfWorkContext context, AddProductToShoppingCart command)
                 {
                     // Get the shopping cart.
                     var shoppingCart = context.GetById(command.ShoppingCartId);
             
                     // Add the product to the shopping cart.
                     shoppingCart.AddProduct(command.ProductId, command.Amount);
            
                     // Accept all the work we just did.
                     context.Accept();
                 }
             }
             </code>
      <typeparam name="TCommand">The type of the commands to execute.</typeparam>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.CommandExecutorBase`1.Execute(`0)">
      <summary>
            Executes the command.
            </summary>
      <param name="command">The command to execute. This should not be null.</param>
      <exception cref="!:ArgumentNullException">Occurs when <i>command</i> is null.</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.CommandExecutorBase`1.ExecuteInContext(Ncqrs.Domain.IUnitOfWorkContext,`0)">
      <summary>
             Executes the command withing an unit of work context.
             <remarks>Make sure you call <see cref="M:Ncqrs.Domain.IUnitOfWorkContext.Accept" /> to accept the changes that has been made in the context.</remarks></summary>
      <example>
        <code lang="c#">
             public class AddProductToShoppingCartExecutor : CommandExecutorBase
             {
                 protected override void ExecuteInContext(IUnitOfWorkContext context, AddProductToShoppingCart command)
                 {
                     // Get the shopping cart.
                     var shoppingCart = context.GetById(command.ShoppingCartId);
             
                     // Add the product to the shopping cart.
                     shoppingCart.AddProduct(command.ProductId, command.Amount);
            
                     // Accept all the work we just did.
                     context.Accept();
                 }
             }
             </code>
      </example>
      <param name="context">The work context.</param>
      <param name="command">The command to execute.</param>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2">
      <summary>
            Represents the method that is to be called on the aggregateroot of type <typeparamref name="TAggRoot" />.
            </summary>
      <typeparam name="TCommand">The command of type <typeparamref name="TCommand" /> that is executing the method.</typeparam>
      <typeparam name="TAggRoot">The aggregateroot of type <typeparamref name="TAggRoot" /> on which we execute the method.</typeparam>
      <invariant description="getidfromcommandfunc can not be null.">_getidfromcommandfunc != null</invariant>
      <invariant description="aggregaterootfetchfunc can not be null.">_aggregaterootfetchfunc != null</invariant>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2.#ctor(System.Func{`0,System.Guid})">
      <summary>
            Constructor, initializes a new instance of <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2" />.
            </summary>
      <param name="getidfromcommandfunc">The method responsible for retrieving the id of the aggregateroot from the command.</param>
      <remarks>Marked as internal because the construction is only allowed in the framework.</remarks>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2.#ctor(System.Func{System.Guid,`1},System.Func{`0,System.Guid})">
      <summary>
            Constructor, initializes a new instance of <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2" />.
            </summary>
      <param name="getidfromcommandfunc">The method responsible for retrieving the id of the aggregateroot from the command.</param>
      <param name="aggregaterootfetchfunc">The method responsible for retrieving the aggregateroot of type <typeparamref name="TAggRoot" /> from a <see cref="T:System.Guid" />.</param>
      <remarks>Marked as internal because the construction is only allowed in the framework.</remarks>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2.ToCallOn(System.Action{`0,`1})">
      <summary>
            Takes a method that is responsible for calling the method on the aggregateroot of type <typeparamref name="TAggRoot" /> 
            with any parameters from the command of type <typeparamref name="TCommand" />.
            </summary>
      <param name="commandmappedfunc">The method that is responsible for the method mapping.</param>
      <returns>The <see cref="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1" /> which is able to execute this command.</returns>
      <requires description="commandmappedfunc can not be null." exception="T:System.ArgumentNullException">commandmappedfunc != null</requires>
      <exception cref="T:System.ArgumentNullException">commandmappedfunc == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRootMethod`2.Ncqrs#Commanding#CommandExecution#ICommandExecutor{TCommand}#Execute(`0)">
      <summary>
            Executes the command.
            </summary>
      <param name="command">The command to execute.</param>
      <returns>The aggregateroot of type <typeparamref name="TAggRoot" /> on which we executed the command.</returns>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommand`1">
      <summary>
            Represents a command of type <see cref="!:TCommand" /> that is to be mapped.
            </summary>
      <typeparam name="TCommand">The command on which we want to map.</typeparam>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommand`1.#ctor">
      <summary>
            Constructor, initializes a new instance of <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommand`1" />.
            </summary>
      <remarks>Marked as internal because the construction is only allowed in the framework.</remarks>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommand`1.ToAggregateRoot``1">
      <summary>
            Creates a <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`2" /> which represents the mapping between
            the command of type <typeparamref name="TCommand" /> and the aggregateroot of type <typeparamref name="TAggRoot" />.
            </summary>
      <typeparam name="TAggRoot">The type of the aggregateroot in which we want to map.</typeparam>
      <returns>A <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommandToAggregateRoot`2" />.</returns>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommand`1.Ncqrs#Commanding#CommandExecution#ICommandExecutor{TCommand}#Execute(`0)">
      <summary>
            Executes the command.
            </summary>
      <param name="command">The command to execute.</param>
      <exception cref="!:ArgumentNullException">Occurs when <i>command</i> is null.</exception>
    </member>
    <member name="P:Ncqrs.Eventing.Storage.StoredEvent.EventName">
      <summary>
              Gets or sets the event name of the original object from which this document was constructed.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.SourcedEventStream.Append(Ncqrs.Eventing.Sourcing.SourcedEvent)">
      <summary>
            Appends the specified sourced event to this steam.
            </summary>
      <exception cref="T:System.ArgumentNullException">Occurs when <paramref name="sourcedEvent" /> is null.</exception>
      <exception cref="T:System.ArgumentException">Occurs when <paramref name="sourcedEvent.EventSourceId" /> is not owned set to the <see cref="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.EventSourceId" /> property of this stream.</exception>
      <exception cref="T:System.ArgumentException">Occurs when <paramref name="sourcedEvent.Sequence" /> is not set to <see cref="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.LastSequence" /><c>+1</c>.</exception>
      <param name="sourcedEvent">The sourced event.</param>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.EventSourceId">
      <summary>
            Gets or sets the id of the <see cref="T:Ncqrs.Eventing.Sourcing.IEventSource" /> that owns the events.
            This property can only be set when the event is <see cref="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.IsEmpty" />.
            </summary>
      <exception cref="T:System.InvalidOperationException">Occurs when this property is set while <see cref="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.IsEmpty" /> is true.</exception>
      <value>
            A <see cref="T:System.Guid" /> that contains the id of the <see cref="T:Ncqrs.Eventing.Sourcing.IEventSource" /> that
            owns this event stream.
            </value>
      <setter>
        <requires exception="T:System.InvalidOperationException">IsEmpty</requires>
      </setter>
      <exception cref="T:System.InvalidOperationException">!(IsEmpty)</exception>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.LastSequence">
      <summary>
            Gets the last sequence in this stream.
            </summary>
      <value>The last sequence.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.SequenceOffset">
      <summary>
            Gets or sets the offset of the event stream. This has influence on the sequence number
            </summary>
      <exception cref="T:System.InvalidOperationException">Occurs when this property is set while <see cref="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.IsEmpty" /> is true.</exception>
      <setter>
        <requires exception="T:System.InvalidOperationException">IsEmpty</requires>
        <requires exception="T:System.ArgumentOutOfRangeException">value &gt;= 0</requires>
      </setter>
      <exception cref="T:System.InvalidOperationException">!(IsEmpty)</exception>
      <exception cref="T:System.ArgumentOutOfRangeException">value &lt; 0</exception>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.Count">
      <summary>
            Gets the number of events in this stream.
            </summary>
      <value>The number of events in this stream. This value is zero when <see cref="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.IsEmpty" /> is <c>true</c>.</value>
    </member>
    <member name="P:Ncqrs.Eventing.Sourcing.SourcedEventStream.IsEmpty">
      <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
      <value>
        <c>true</c> if this instance is empty; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor">
      <summary>
            Allows users to intercept commands before or after they has been
            executed in a command service. This allows them to add additional
            behavior before or after the execution of commands. The 
            <see cref="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnBeforeExecution(Ncqrs.Commanding.ServiceModel.CommandContext)" /> method will be called before every
            command execution and <see cref="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnAfterExecution(Ncqrs.Commanding.ServiceModel.CommandContext)" /> will be called
            after every command execution.
            </summary>
      <example>
            The following code explains the different things that could happen in
            the context of interception.
            <code lang="c#">
            public class SampleInterceptor : ICommandServiceInterceptor
            {
                public void OnBeforeBeforeExecutorResolving(CommandContext context)
                {
                    if(context.TheCommandType == typeof(MyCommand))
                    {
                        // Convert the command to MyCommandV2.
                        MyCommand cmd = (MyCommand)context.TheCommand;
                        context.TheCommandType = MyCommandV2.CreateFrom(cmd);
                    }
                }
            
                public void OnBeforeExecution(CommandContext context)
                {
                    // Null when no executor was found for the command; otherwise, it hold
                    // the executor that will be called to execute the command after all
                    // interceptors has been called.
                    var executor = context.TheCommandExecutor;
            
                    // This is allways null in OnBeforeExecution.
                    var exception = context.Exception;
            
                    // This is allways false in OnBeforeExecution.
                    var isExecuted = context.IsExecuted;
            
                    // Holds the command that will be executed.
                    // This is never a null dereference.
                    var command = context.TheCommand;
            
                    // Holds the type of the command that will be
                    // executed. This is never a null dereference.
                    var commandType = context.TheCommandType;
                }
            
                public void OnAfterExecution(CommandContext context)
                {
                    // Null when no executor was found for the command; otherwise, it hold
                    // the executor that was called to execute the command.
                    var executor = context.TheCommandExecutor;
            
                    // If occurred, it holds the exception that was been thrown in the context; otherwise, null.
                    // Use the context.IsExecuted method to dermine whether the 
                    var exception = context.Exception;
            
                    // Holds true whenever the command executor is called to execute the command. This does
                    // not mean the execution was succesfull. Check the context.Exception method to dermine
                    // whether there was an exception on execution.
                    // When this holds false, this means the command was not executed due the fact that there
                    // was not handler found, or that an interceptor throwed an exception.
                    var isExecuted = context.IsExecuted;
            
                    // Holds the command that was been executed.
                    var command = context.TheCommand;
            
                    // Holds the type of the command that will be
                    // executed. This is never a null dereference.
                    var commandType = context.TheCommandType;
                }
            }
            </code></example>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnBeforeBeforeExecutorResolving(Ncqrs.Commanding.ServiceModel.CommandContext)">
      <summary>
            Intercepts a command execution before the command executor is
            resolved.
            <para>In this method the interceptor may override the command by
            setting the <see cref="P:Ncqrs.Commanding.ServiceModel.CommandContext.TheCommand" /> property.</para></summary>
      <param name="context">The context of the current command execution.
            </param>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnBeforeExecution(Ncqrs.Commanding.ServiceModel.CommandContext)">
      <summary>
            Intercepts a command execution before the command will be executed,
            but after the executor has been resolved.
            </summary>
      <param name="context">The context of the current command execution.
            </param>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnAfterExecution(Ncqrs.Commanding.ServiceModel.CommandContext)">
      <summary>
            Intercepts a command execution when a exception has been occurred or
            after the command has been executed. See the 
            <see cref="P:Ncqrs.Commanding.ServiceModel.CommandContext.ExecutorHasBeenCalled" /> to determine whether the
            command has been executed.
            </summary>
      <param name="context">The context of the current command
            execution.
            </param>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.TypeAndCallbackThresholdedActionBasedDomainEventHandler">
      <summary>
             An event handler that uses a specified action as handler, but only calls this when the event
             is accepted by provided callback method and is of a certain type, or is inherited from it.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.TypeAndCallbackThresholdedActionBasedDomainEventHandler.#ctor(System.Action{Ncqrs.Eventing.Sourcing.SourcedEvent},System.Func{Ncqrs.Eventing.Sourcing.SourcedEvent,System.Boolean},System.Type,System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Sourcing.TypeAndCallbackThresholdedActionBasedDomainEventHandler" /> class.
            </summary>
      <param name="handler">The handler that will be called to handle a event when the threshold did not hold the event.</param>
      <param name="filterCallback">A filter function.</param>
      <param name="eventTypeThreshold">The event type that should be used as threshold.</param>
      <param name="exact">if set to <c>true</c> the threshold will hold all types that are not the same type; otherwise it hold 
            all types that are not inhered from the event type threshold or implement the interface that is specified by the threshold type.</param>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.Mapping.EventHandlerAttribute">
      <summary>
            Indicates that a method is an event handler.
            </summary>
      <remarks>
            The marked method should not be static and should have on parameter that is of the type <see cref="T:Ncqrs.Eventing.Sourcing.SourcedEvent" />.
            </remarks>
    </member>
    <member name="T:Ncqrs.Commanding.ServiceModel.CommandContext">
      <summary>Represents the context of a command execution in an 
            <see cref="T:Ncqrs.Commanding.ServiceModel.ICommandService" />. This context is passed through 
            <see cref="T:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor">interceptors</see> for each
            interception.</summary>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandContext.#ctor(Ncqrs.Commanding.ICommand)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.ServiceModel.CommandContext" /> class.
            </summary>
      <param name="theCommand">The command that will be executed.</param>
      <requires description="The theCommand cannot be null." exception="T:System.ArgumentNullException">theCommand != null</requires>
      <exception cref="T:System.ArgumentNullException">theCommand == null</exception>
    </member>
    <member name="P:Ncqrs.Commanding.ServiceModel.CommandContext.Exception">
      <summary>
        <para>Gets the exception that has occurred while handling the event.
            Use the <see cref="P:Ncqrs.Commanding.ServiceModel.CommandContext.ExecutorHasBeenCalled" /> property to determine whether
            the exception has been thrown by a interceptor or by the execution
            itself.</para>
      </summary>
      <value>The exception that has been occurred or <c>null</c> when it
            has not.</value>
    </member>
    <member name="P:Ncqrs.Commanding.ServiceModel.CommandContext.ExecutorResolved">
      <summary>
            Gets a value indicating whether an executor has been resolved.
            </summary>
      <value>
        <c>true</c> if an executor has been resolved for this command; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Ncqrs.Commanding.ServiceModel.CommandContext.TheCommand">
      <summary>
            Gets the command that will be or is executed.
            </summary>
      <exception cref="T:System.InvalidOperationException">Occurs when this
            property is set while the <see cref="P:Ncqrs.Commanding.ServiceModel.CommandContext.ExecutorResolved" /> property
            return true indicating that a executor has been resolved for the command.</exception>
      <value>The command that will or has been executed. This value is never <c>null</c>.</value>
      <getter>
        <ensures description="The result cannot be null.">Contract.Result&lt;ICommand&gt;() != null</ensures>
      </getter>
      <setter>
        <requires description="Cannot override command when a command executor has already been resolved." exception="T:System.InvalidOperationException">!ExecutorResolved</requires>
      </setter>
      <exception cref="T:System.InvalidOperationException">ExecutorResolved</exception>
    </member>
    <member name="P:Ncqrs.Commanding.ServiceModel.CommandContext.TheCommandType">
      <summary>
            Gets the type of the command.
            </summary>
      <value>The type of the command.</value>
    </member>
    <member name="P:Ncqrs.Commanding.ServiceModel.CommandContext.ExecutorHasBeenCalled">
      <summary>
            Gets a value indicating whether the executor for the command has
            been called.
            </summary>
      <value>
        <c>true</c> if the executor for this command has been called;
            	otherwise, <c>false</c>. <c>true</c> does not have to mean that the
            	executor also executed the command. It could be that an exception
            	had occurred.
            <remarks>
            This value is always <c>false</c> in the 
            <see cref="M:Ncqrs.Commanding.ServiceModel.ICommandServiceInterceptor.OnBeforeExecution(Ncqrs.Commanding.ServiceModel.CommandContext)" />.
            </remarks></value>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.Map">
      <summary>
            Static Map class that defines easy to use command mapping methods.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.Map.Command``1">
      <summary>
            Creates a new <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommand`1" /> which can be used for fluent mapping.
            </summary>
      <typeparam name="TCommand">The type of command.</typeparam>
      <returns>A <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.MappedCommand`1" />.</returns>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Fluent.Map.Command``1(Ncqrs.Commanding.CommandExecution.Mapping.Attributes.AttributeMappedCommandExecutor{``0})">
      <summary>
            Returns a <see cref="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1" /> for attribute based mappings.
            </summary>
      <typeparam name="TCommand">The type of command.</typeparam>
      <returns>An <see cref="T:Ncqrs.Commanding.CommandExecution.ICommandExecutor`1" />.</returns>
    </member>
    <member name="T:Ncqrs.Config.IEnvironmentConfiguration">
      <summary>
            A configuration that can resolve requested instances.
            </summary>
    </member>
    <member name="M:Ncqrs.Config.IEnvironmentConfiguration.TryGet``1(``0@)">
      <summary>
            Tries to get the specified instance.
            </summary>
      <typeparam name="T">The type of the instance to get.</typeparam>
      <param name="result">The result.</param>
      <returns>A indication whether the instance could be get or not.</returns>
      <ensures>Contract.Result&lt;bool&gt;() ? Contract.ValueAtReturn(out result) != null : Contract.ValueAtReturn(out result) == null</ensures>
    </member>
    <member name="T:Ncqrs.Eventing.Storage.SimpleEventTypeResolver">
      <summary>
            This resolves types using their assembly qualified name.
            </summary>
      <remarks>
            This is not recommended for production use as it means event names will be affected by changes
            to namespaces and class names.
            </remarks>
      <seealso cref="T:Ncqrs.Eventing.Storage.AttributeEventTypeResolver" />
    </member>
    <member name="T:Ncqrs.Eventing.Storage.Serialization.NullEventConverter">
      <summary>
            An event converter that does nothing.
            </summary>
      <remarks>
            This is useful when you have to provide an event converter
            but do not need to upgrade events to newer versions.
            </remarks>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.Snapshotting.ISnapshotable`1">
      <summary>
            This interface flags an object beeing <i>snapshotable</i>. This means
            that the state of the object could be saved to an 
            <see cref="T:Ncqrs.Eventing.Sourcing.Snapshotting.ISnapshot" /> object and restored from a the from the same
            class. This is used to prevent building <see cref="!:AggregateRoot" />'s
            from the ground up.
            </summary>
      <remarks>
            Only one <see cref="T:Ncqrs.Eventing.Sourcing.Snapshotting.ISnapshotable`1" /> can be implemented. If
            you implement more than one, it will cause an exception when saving this
            instance.
            </remarks>
    </member>
    <member name="T:Ncqrs.Commanding.CommandExecution.Mapping.MappingNotFoundException">
      <summary>
            Occurs when there is no auto mapping found for a <see cref="T:Ncqrs.Commanding.ICommand" />.
            </summary>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.MappingNotFoundException.#ctor(System.String,Ncqrs.Commanding.ICommand)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.MappingNotFoundException" /> class.
            </summary>
      <param name="message">The message.</param>
      <param name="command">The command.</param>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.MappingNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.MappingNotFoundException" /> class with serialized data.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown. </param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination. </param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Ncqrs.Commanding.CommandExecution.Mapping.MappingNotFoundException.Command">
      <summary>
            Gets the command.
            </summary>
      <value>The command.</value>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.AttributeBasedMappingFactory.IsCommandMapped(System.Type)">
      <summary>
            Determines whether the type is a mapped command.
            </summary>
      <remarks>
            A type is a mapped command when it implements the <see cref="T:Ncqrs.Commanding.ICommand" /> interface
            and is marked with an attribute that inhires the <see cref="T:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.CommandMappingAttribute" />.
            </remarks>
      <param name="type">The type to check. This value cannot be null.</param>
      <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="type" /> is <c>null</c>.
            </exception>
      <returns>
        <c>true</c> if [is command mapped] [the specified target]; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.Mapping.ConventionBasedSourcedEventHandlerMappingStrategy">
      <summary>
            A internal event handler mapping strategy that maps methods as an event handler based on method name and parameter type.
            <remarks>
            All method that match the following requirements are mapped as an event handler:
            <list type="number"><item><value>
                        Method name should start with <i>On</i> or <i>on</i>. Like: <i>OnProductAdded</i> or <i>onProductAdded</i>.
                    </value></item><item><value>
                        The method should only accept one parameter.
                    </value></item><item><value>
                        The parameter must be, or inhired from, the <see cref="T:Ncqrs.Eventing.Sourcing.SourcedEvent" /> class.
                    </value></item></list></remarks></summary>
    </member>
    <member name="T:Ncqrs.LogManager">
      <summary>
            A manager class to use to get a logger for a certain type.
            </summary>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.TypeThresholdedActionBasedDomainEventHandler">
      <summary>
              An event handler that uses a specified action as handler, but only calls this when the event
              is of a certain type, or is inherited from it.
            </summary>
      <invariant>_handler != null</invariant>
      <invariant>_eventTypeThreshold != null</invariant>
    </member>
    <member name="F:Ncqrs.Eventing.Sourcing.TypeThresholdedActionBasedDomainEventHandler._eventTypeThreshold">
      <summary>
              The event type that should be used as threshold.
            </summary>
    </member>
    <member name="F:Ncqrs.Eventing.Sourcing.TypeThresholdedActionBasedDomainEventHandler._exact">
      <summary>
              Specifies whether the event type threshold should be used as an exact or at least threshold.
            </summary>
      <remarks>
        <c>true</c> means that the event type threshold should be the same type as the event, otherwise
              the event handler will not be executed. <c>false</c> means that the threshold type should be in 
              the inheritance hierarchy of the event type, or that the threshold type should be an interface 
              that the event type implements, otherwise the handler will not be executed.
            </remarks>
    </member>
    <member name="F:Ncqrs.Eventing.Sourcing.TypeThresholdedActionBasedDomainEventHandler._handler">
      <summary>
              The handler that should be called when the threshold did not hold the event.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.TypeThresholdedActionBasedDomainEventHandler.#ctor(System.Action{Ncqrs.Eventing.Sourcing.SourcedEvent},System.Type,System.Boolean)">
      <summary>
              Initializes a new instance of the <see cref="T:Ncqrs.Eventing.Sourcing.TypeThresholdedActionBasedDomainEventHandler" /> class.
            </summary>
      <param name="handler">The handler that will be called to handle a event when the threshold did not hold the event.</param>
      <param name="eventTypeThreshold">The event type that should be used as threshold.</param>
      <param name="exact">if set to <c>true</c> the threshold will hold all types that are not the same type; otherwise it hold 
            all types that are not inhered from the event type threshold or implement the interface that is specified by the threshold type.</param>
      <requires description="The handler cannot be null." exception="T:System.ArgumentNullException">handler != null</requires>
      <exception cref="T:System.ArgumentNullException">handler == null</exception>
      <requires description="The eventTypeThreshold cannot be null." exception="T:System.ArgumentNullException">eventTypeThreshold != null</requires>
      <exception cref="T:System.ArgumentNullException">eventTypeThreshold == null</exception>
      <requires description="The eventTypeThreshold should be of a type that implements the IEvent interface." exception="T:System.ArgumentException">typeof(IEvent).IsAssignableFrom(eventTypeThreshold)</requires>
      <exception cref="T:System.ArgumentException">!(typeof(IEvent).IsAssignableFrom(eventTypeThreshold))</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.TypeThresholdedActionBasedDomainEventHandler.HandleEvent(Ncqrs.Eventing.Sourcing.SourcedEvent)">
      <summary>
              Handles the event.
            </summary>
      <param name="evnttData">The event data to handle.
              <remarks>
                This value should not be <c>null</c>.
              </remarks></param>
      <returns>
        <c>true</c> when the event was handled; otherwise, <c>false</c>.
              <remarks><c>false</c> does not mean that the handling failed, but that the
                handler was not interested in handling this event.
              </remarks></returns>
      <requires description="The Event cannot be null." exception="T:System.ArgumentNullException">evnt != null</requires>
      <exception cref="T:System.ArgumentNullException">evnt == null</exception>
      <requires description="The sourcedEvent cannot be null." inheritedFrom="M:Ncqrs.Eventing.Sourcing.ISourcedEventHandler.HandleEvent(Ncqrs.Eventing.Sourcing.SourcedEvent)" inheritedFromTypeName="ISourcedEventHandler" exception="T:System.ArgumentNullException">sourcedEvent != null</requires>
      <exception cref="T:System.ArgumentNullException">sourcedEvent == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.TypeThresholdedActionBasedDomainEventHandler.ObjectInvariants">
      <summary>
              This method holds all the objects invariants.
            </summary>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.TypeThresholdedActionBasedDomainEventHandler.ShouldHandleThisEventData(Ncqrs.Eventing.IEvent)">
      <summary>
              Determine whether the event should be handled or not.
            </summary>
      <param name="evnttData">The event data.</param>
      <returns>
        <c>true</c> when this event should be handled; otherwise, <c>false</c>.</returns>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.InProcessEventBus.PublishToHandlers(Ncqrs.Eventing.IEvent,System.Type,System.Collections.Generic.IEnumerable{System.Action{Ncqrs.Eventing.IEvent}})">
      <requires exception="T:System.ArgumentNullException">handlers != null</requires>
      <exception cref="T:System.ArgumentNullException">handlers == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.InProcessEventBus.TransactionallyPublishToHandlers(Ncqrs.Eventing.IEvent,System.Type,System.Collections.Generic.IEnumerable{System.Action{Ncqrs.Eventing.IEvent}})">
      <requires exception="T:System.ArgumentNullException">handlers != null</requires>
      <exception cref="T:System.ArgumentNullException">handlers == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.ServiceModel.Bus.RegisterAllHandlersInAssemblyExtension.CreateInstance(System.Type)">
      <requires exception="T:System.ArgumentNullException">type != null</requires>
      <exception cref="T:System.ArgumentNullException">type == null</exception>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.EventSource">
      <invariant description="The member _unacceptedEvents should never be null.">_uncommittedEvents != null</invariant>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.EventSource.HandleEvent(Ncqrs.Eventing.Sourcing.SourcedEvent)">
      <requires description="The Event cannot be null." exception="T:System.ArgumentNullException">evnt != null</requires>
      <exception cref="T:System.ArgumentNullException">evnt == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.EventSource.RegisterHandler(Ncqrs.Eventing.Sourcing.ISourcedEventHandler)">
      <requires description="The handler cannot be null." exception="T:System.ArgumentNullException">handler != null</requires>
      <exception cref="T:System.ArgumentNullException">handler == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.EventSource.GetUncommittedEvents">
      <ensures description="The result of this method should never be null.">Contract.Result&lt;IEnumerable&lt;SourcedEvent&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.Mapping.AttributeBasedSourcedEventHandlerMappingStrategy.FirstParameterType(System.Reflection.MethodInfo)">
      <requires description="The target cannot be null." exception="T:System.ArgumentNullException">target != null</requires>
      <exception cref="T:System.ArgumentNullException">target == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.Mapping.AttributeBasedSourcedEventHandlerMappingStrategy.NumberOfParameters(System.Reflection.MethodInfo)">
      <requires description="The target cannot be null." exception="T:System.ArgumentNullException">target != null</requires>
      <exception cref="T:System.ArgumentNullException">target == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.Mapping.AttributeBasedSourcedEventHandlerMappingStrategy.IsMarkedAsEventHandler(System.Reflection.MethodInfo,Ncqrs.Eventing.Sourcing.Mapping.EventHandlerAttribute@)">
      <requires description="The target cannot be null." exception="T:System.ArgumentNullException">target != null</requires>
      <exception cref="T:System.ArgumentNullException">target == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.Mapping.ConventionBasedSourcedEventHandlerMappingStrategy.GetEventHandlersFromAggregateRoot(System.Object)">
      <requires description="The eventSource cannot be null." exception="T:System.ArgumentNullException">eventSource != null</requires>
      <exception cref="T:System.ArgumentNullException">eventSource == null</exception>
      <ensures description="The result should never be null.">Contract.Result&lt;IEnumerable&lt;ISourcedEventHandler&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.Mapping.MappedAggregateRoot.#ctor(Ncqrs.Eventing.Sourcing.Mapping.ISourcedEventHandlerMappingStrategy)">
      <requires description="The strategy cannot be null." exception="T:System.ArgumentNullException">strategy != null</requires>
      <exception cref="T:System.ArgumentNullException">strategy == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.SourcedEventHander`1.Ncqrs#Eventing#Sourcing#ISourcedEventHandler#HandleEvent(Ncqrs.Eventing.Sourcing.SourcedEvent)">
      <requires description="The sourcedEvent cannot be null." inheritedFrom="M:Ncqrs.Eventing.Sourcing.ISourcedEventHandler.HandleEvent(Ncqrs.Eventing.Sourcing.SourcedEvent)" inheritedFromTypeName="ISourcedEventHandler" exception="T:System.ArgumentNullException">sourcedEvent != null</requires>
      <exception cref="T:System.ArgumentNullException">sourcedEvent == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.TypeAndCallbackThresholdedActionBasedDomainEventHandler.HandleEvent(Ncqrs.Eventing.Sourcing.SourcedEvent)">
      <requires description="The sourcedEvent cannot be null." inheritedFrom="M:Ncqrs.Eventing.Sourcing.ISourcedEventHandler.HandleEvent(Ncqrs.Eventing.Sourcing.SourcedEvent)" inheritedFromTypeName="ISourcedEventHandler" exception="T:System.ArgumentNullException">sourcedEvent != null</requires>
      <exception cref="T:System.ArgumentNullException">sourcedEvent == null</exception>
    </member>
    <member name="T:Ncqrs.Eventing.Sourcing.SourcedEventStream">
      <invariant>_sequenceOffset &gt;= 0</invariant>
      <invariant>Contract.ForAll(_events, (sourcedEvent) =&gt; sourcedEvent.EventSourceId == _eventSourceId)</invariant>
      <invariant>Contract.ForAll(_events, (sourcedEvent) =&gt; sourcedEvent.EventSequence == (_sequenceOffset + _events.IndexOf(sourcedEvent) + 1))</invariant>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.SourcedEventStream.GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&lt;T&gt;&gt;().Model == ((IEnumerable)this).Model</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.SourcedEventStream.#ctor(System.Guid,System.Int64)">
      <requires>sequenceOffset &gt;= 0</requires>
    </member>
    <member name="M:Ncqrs.Eventing.Sourcing.SourcedEventStream.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;() != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().Model == this.Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable">Contract.Result&lt;IEnumerator&gt;().CurrentIndex == -1</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.AttributeEventTypeResolver.ResolveType(System.String)">
      <requires inheritedFrom="M:Ncqrs.Eventing.Storage.IEventTypeResolver.ResolveType(System.String)" inheritedFromTypeName="IEventTypeResolver">eventName != null</requires>
      <ensures inheritedFrom="M:Ncqrs.Eventing.Storage.IEventTypeResolver.ResolveType(System.String)" inheritedFromTypeName="IEventTypeResolver">Contract.Result&lt;Type&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.AttributeEventTypeResolver.EventNameFor(System.Type)">
      <requires inheritedFrom="M:Ncqrs.Eventing.Storage.IEventTypeResolver.EventNameFor(System.Type)" inheritedFromTypeName="IEventTypeResolver">type != null</requires>
      <ensures inheritedFrom="M:Ncqrs.Eventing.Storage.IEventTypeResolver.EventNameFor(System.Type)" inheritedFromTypeName="IEventTypeResolver">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SimpleEventTypeResolver.ResolveType(System.String)">
      <requires inheritedFrom="M:Ncqrs.Eventing.Storage.IEventTypeResolver.ResolveType(System.String)" inheritedFromTypeName="IEventTypeResolver">eventName != null</requires>
      <ensures inheritedFrom="M:Ncqrs.Eventing.Storage.IEventTypeResolver.ResolveType(System.String)" inheritedFromTypeName="IEventTypeResolver">Contract.Result&lt;Type&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.SimpleEventTypeResolver.EventNameFor(System.Type)">
      <requires inheritedFrom="M:Ncqrs.Eventing.Storage.IEventTypeResolver.EventNameFor(System.Type)" inheritedFromTypeName="IEventTypeResolver">type != null</requires>
      <ensures inheritedFrom="M:Ncqrs.Eventing.Storage.IEventTypeResolver.EventNameFor(System.Type)" inheritedFromTypeName="IEventTypeResolver">Contract.Result&lt;string&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.InMemoryEventStore.Save(Ncqrs.Eventing.Sourcing.IEventSource)">
      <requires description="source cannot be null." inheritedFrom="M:Ncqrs.Eventing.Storage.IEventStore.Save(Ncqrs.Eventing.Sourcing.IEventSource)" inheritedFromTypeName="IEventStore" exception="T:System.ArgumentNullException">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.InMemoryEventStore.GetAllEvents(System.Guid)">
      <ensures description="Result should never be null." inheritedFrom="M:Ncqrs.Eventing.Storage.IEventStore.GetAllEvents(System.Guid)" inheritedFromTypeName="IEventStore">Contract.Result&lt;IEnumerable&lt;SourcedEvent&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Eventing.Storage.Serialization.NullEventConverter.Upgrade(Ncqrs.Eventing.Storage.StoredEvent{Newtonsoft.Json.Linq.JObject})">
      <requires description="theEvent" inheritedFrom="M:Ncqrs.Eventing.Storage.Serialization.IEventConverter.Upgrade(Ncqrs.Eventing.Storage.StoredEvent{Newtonsoft.Json.Linq.JObject})" inheritedFromTypeName="IEventConverter" exception="T:System.ArgumentNullException">theEvent != null</requires>
      <exception cref="T:System.ArgumentNullException">theEvent == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Storage.DomainRepository.Save(Ncqrs.Domain.AggregateRoot)">
      <requires inheritedFrom="M:Ncqrs.Domain.Storage.IDomainRepository.Save(Ncqrs.Domain.AggregateRoot)" inheritedFromTypeName="IDomainRepository" exception="T:System.ArgumentNullException">aggregateRootToSave != null</requires>
      <exception cref="T:System.ArgumentNullException">aggregateRootToSave == null</exception>
    </member>
    <member name="M:Ncqrs.Domain.Storage.DomainRepository.#ctor(Ncqrs.Eventing.Storage.IEventStore,Ncqrs.Eventing.ServiceModel.Bus.IEventBus,Ncqrs.Eventing.Storage.ISnapshotStore,Ncqrs.Domain.Storage.IAggregateRootCreationStrategy)">
      <requires exception="T:System.ArgumentNullException">store != null</requires>
      <exception cref="T:System.ArgumentNullException">store == null</exception>
      <requires exception="T:System.ArgumentNullException">eventBus != null</requires>
      <exception cref="T:System.ArgumentNullException">eventBus == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.ServiceModel.CommandService.RegisterExecutor``1(System.Type,Ncqrs.Commanding.CommandExecution.ICommandExecutor{``0})">
      <requires exception="T:System.ArgumentOutOfRangeException">typeof(TCommand).IsAssignableFrom(commandType)</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">!(typeof(TCommand).IsAssignableFrom(commandType))</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.DirectActionCommandExecutor`2.#ctor(System.Func{`0,System.Guid},System.Action{`1,`0},Ncqrs.Domain.IUnitOfWorkFactory)">
      <requires description="The getId parameter cannot be null." exception="T:System.ArgumentNullException">getId != null</requires>
      <exception cref="T:System.ArgumentNullException">getId == null</exception>
      <requires description="The action parameter cannot be null." exception="T:System.ArgumentNullException">action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
      <requires description="The uowFactory parameter cannot be null." exception="T:System.ArgumentNullException">uowFactory != null</requires>
      <exception cref="T:System.ArgumentNullException">uowFactory == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.DirectActionCommandExecutor`2.#ctor(System.Func{`0,System.Guid},System.Action{`1,`0})">
      <requires description="The getId parameter cannot be null." exception="T:System.ArgumentNullException">getId != null</requires>
      <exception cref="T:System.ArgumentNullException">getId == null</exception>
      <requires description="The action parameter cannot be null." exception="T:System.ArgumentNullException">action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.Attributes.AttributeBasedMappingFactory.CreateExecutorForCommand``1">
      <ensures>Contract.Result &lt;ICommandExecutor&lt;TCommand&gt;&gt;() != null</ensures>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.PropertiesToMethodMapper.MakeSureAllPropertiesToMapOnNameHaveUniqueNames(System.Collections.Generic.List{Ncqrs.Commanding.CommandExecution.Mapping.PropertyToParameterMappingInfo})">
      <requires exception="T:System.ArgumentNullException">propertiesToMap != null</requires>
      <exception cref="T:System.ArgumentNullException">propertiesToMap == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.Mapping.PropertiesToMethodMapper.MakeSureAllPropertieOrdinalsAreUnique(System.Collections.Generic.List{Ncqrs.Commanding.CommandExecution.Mapping.PropertyToParameterMappingInfo})">
      <requires exception="T:System.ArgumentNullException">propertiesToMap != null</requires>
      <exception cref="T:System.ArgumentNullException">propertiesToMap == null</exception>
    </member>
    <member name="M:Ncqrs.Commanding.CommandExecution.CreatingCommandExecutor`2.#ctor(System.Func{`0,`1},Ncqrs.Domain.IUnitOfWorkFactory)">
      <requires description="The action cannot be null." exception="T:System.ArgumentNullException">create != null</requires>
      <exception cref="T:System.ArgumentNullException">create == null</exception>
    </member>
  </members>
</doc>